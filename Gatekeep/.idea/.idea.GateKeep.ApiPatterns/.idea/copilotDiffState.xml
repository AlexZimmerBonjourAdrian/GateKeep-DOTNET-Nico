<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/scripts/test-login-simple.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/test-login-simple.ps1" />
              <option name="updatedContent" value="# Prueba simple del endpoint de login&#10;$outputFile = &quot;C:\Users\Felipe\RiderProjects\GateKeep-DOTNET-Nico\Gatekeep\scripts\test-result.txt&quot;&#10;&#10;&quot;=== PRUEBA DEL ENDPOINT DE LOGIN ===&quot; | Out-File $outputFile&#10;&quot;Fecha: $(Get-Date)&quot; | Out-File $outputFile -Append&#10;&quot;&quot; | Out-File $outputFile -Append&#10;&#10;# Prueba 1: Health check&#10;&quot;1. Verificando estado de la API...&quot; | Out-File $outputFile -Append&#10;try {&#10;    $health = Invoke-RestMethod -Uri &quot;http://localhost:5011/health&quot; -Method GET&#10;    &quot;   EXITO: API respondiendo - $($health | ConvertTo-Json)&quot; | Out-File $outputFile -Append&#10;} catch {&#10;    &quot;   ERROR: $($_.Exception.Message)&quot; | Out-File $outputFile -Append&#10;}&#10;&#10;&quot;&quot; | Out-File $outputFile -Append&#10;&#10;# Prueba 2: Login con credenciales correctas&#10;&quot;2. Probando LOGIN con admin@gatekeep.com / admin123...&quot; | Out-File $outputFile -Append&#10;try {&#10;    $body = @{&#10;        email = &quot;admin@gatekeep.com&quot;&#10;        password = &quot;admin123&quot;&#10;    } | ConvertTo-Json&#10;&#10;    $response = Invoke-RestMethod -Uri &quot;http://localhost:5011/auth/login&quot; -Method POST -ContentType &quot;application/json&quot; -Body $body&#10;    &#10;    &quot;   EXITO: Login funcionó correctamente!&quot; | Out-File $outputFile -Append&#10;    &quot;   Respuesta completa:&quot; | Out-File $outputFile -Append&#10;    $response | ConvertTo-Json -Depth 5 | Out-File $outputFile -Append&#10;    &#10;} catch {&#10;    &quot;   ERROR: Login falló&quot; | Out-File $outputFile -Append&#10;    &quot;   Status Code: $($_.Exception.Response.StatusCode.value__)&quot; | Out-File $outputFile -Append&#10;    &quot;   Mensaje: $($_.Exception.Message)&quot; | Out-File $outputFile -Append&#10;}&#10;&#10;&quot;&quot; | Out-File $outputFile -Append&#10;&quot;=== FIN DE LA PRUEBA ===&quot; | Out-File $outputFile -Append&#10;&#10;# Mostrar resultado&#10;Get-Content $outputFile&#10;Write-Host &quot;&quot;&#10;Write-Host &quot;Resultados guardados en: $outputFile&quot; -ForegroundColor Cyan&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/test-login.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/test-login.ps1" />
              <option name="updatedContent" value="# Script para probar el endpoint de login&#10;Write-Host &quot;=== Prueba del Endpoint de Login ===&quot; -ForegroundColor Cyan&#10;Write-Host &quot;&quot;&#10;&#10;# Verificar que la API esté corriendo&#10;Write-Host &quot;1. Verificando que la API esté corriendo...&quot; -ForegroundColor Yellow&#10;try {&#10;    $health = Invoke-RestMethod -Uri &quot;http://localhost:5011/health&quot; -Method GET -TimeoutSec 5&#10;    Write-Host &quot;   ✓ API está respondiendo: $($health | ConvertTo-Json)&quot; -ForegroundColor Green&#10;} catch {&#10;    Write-Host &quot;   ✗ Error: La API no está respondiendo&quot; -ForegroundColor Red&#10;    Write-Host &quot;   Detalle: $($_.Exception.Message)&quot; -ForegroundColor Red&#10;    exit 1&#10;}&#10;&#10;Write-Host &quot;&quot;&#10;&#10;# Probar login con credenciales correctas&#10;Write-Host &quot;2. Probando login con credenciales correctas (admin@gatekeep.com / admin123)...&quot; -ForegroundColor Yellow&#10;try {&#10;    $loginBody = @{&#10;        email = &quot;admin@gatekeep.com&quot;&#10;        password = &quot;admin123&quot;&#10;    } | ConvertTo-Json&#10;&#10;    $response = Invoke-RestMethod -Uri &quot;http://localhost:5011/auth/login&quot; -Method POST -ContentType &quot;application/json&quot; -Body $loginBody -TimeoutSec 10&#10;    &#10;    Write-Host &quot;   ✓ Login exitoso!&quot; -ForegroundColor Green&#10;    Write-Host &quot;&quot;&#10;    Write-Host &quot;Respuesta del servidor:&quot; -ForegroundColor Cyan&#10;    Write-Host &quot;----------------------&quot; -ForegroundColor Cyan&#10;    Write-Host ($response | ConvertTo-Json -Depth 5)&#10;    Write-Host &quot;&quot;&#10;    &#10;    if ($response.token) {&#10;        Write-Host &quot;   ✓ Token JWT recibido&quot; -ForegroundColor Green&#10;        Write-Host &quot;   Token (primeros 50 caracteres): $($response.token.Substring(0, [Math]::Min(50, $response.token.Length)))...&quot; -ForegroundColor Gray&#10;    }&#10;    &#10;    if ($response.user) {&#10;        Write-Host &quot;   ✓ Información de usuario recibida&quot; -ForegroundColor Green&#10;        Write-Host &quot;   Usuario: $($response.user.nombre) $($response.user.apellido)&quot; -ForegroundColor Gray&#10;        Write-Host &quot;   Email: $($response.user.email)&quot; -ForegroundColor Gray&#10;        Write-Host &quot;   Rol: $($response.user.tipoUsuario)&quot; -ForegroundColor Gray&#10;    }&#10;    &#10;} catch {&#10;    Write-Host &quot;   ✗ Error en login&quot; -ForegroundColor Red&#10;    Write-Host &quot;   Status Code: $($_.Exception.Response.StatusCode.value__)&quot; -ForegroundColor Red&#10;    Write-Host &quot;   Detalle: $($_.Exception.Message)&quot; -ForegroundColor Red&#10;    &#10;    if ($_.Exception.Response.StatusCode.value__ -eq 401) {&#10;        Write-Host &quot;&quot;&#10;        Write-Host &quot;   ⚠ PROBLEMA: El endpoint retornó 401 Unauthorized&quot; -ForegroundColor Yellow&#10;        Write-Host &quot;   Esto significa que el endpoint todavía requiere autenticación cuando no debería&quot; -ForegroundColor Yellow&#10;    }&#10;    exit 1&#10;}&#10;&#10;Write-Host &quot;&quot;&#10;&#10;# Probar login con credenciales incorrectas&#10;Write-Host &quot;3. Probando login con credenciales incorrectas (debe fallar)...&quot; -ForegroundColor Yellow&#10;try {&#10;    $loginBody = @{&#10;        email = &quot;admin@gatekeep.com&quot;&#10;        password = &quot;wrongpassword&quot;&#10;    } | ConvertTo-Json&#10;&#10;    $response = Invoke-RestMethod -Uri &quot;http://localhost:5011/auth/login&quot; -Method POST -ContentType &quot;application/json&quot; -Body $loginBody -TimeoutSec 10 -ErrorAction Stop&#10;    Write-Host &quot;   ✗ PROBLEMA: El login debería haber fallado con credenciales incorrectas&quot; -ForegroundColor Red&#10;} catch {&#10;    if ($_.Exception.Response.StatusCode.value__ -eq 401) {&#10;        Write-Host &quot;   ✓ Login falló correctamente con 401 Unauthorized (comportamiento esperado)&quot; -ForegroundColor Green&#10;    } else {&#10;        Write-Host &quot;   ✓ Login falló con código: $($_.Exception.Response.StatusCode.value__)&quot; -ForegroundColor Green&#10;    }&#10;}&#10;&#10;Write-Host &quot;&quot;&#10;Write-Host &quot;=== Prueba Completada ===&quot; -ForegroundColor Cyan&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/GateKeep.Api/Endpoints/Auth/AuthEndpoints.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/GateKeep.Api/Endpoints/Auth/AuthEndpoints.cs" />
              <option name="originalContent" value="using GateKeep.Api.Contracts.Security;&#10;using GateKeep.Api.Contracts.Usuarios;&#10;using GateKeep.Api.Application.Security;&#10;using GateKeep.Api.Application.Usuarios;&#10;using GateKeep.Infrastructure.QrCodes;&#10;using System.Security.Claims;&#10;&#10;namespace GateKeep.Api.Endpoints.Auth;&#10;&#10;public static class AuthEndpoints&#10;{&#10;    public static IEndpointRouteBuilder MapAuthEndpoints(this IEndpointRouteBuilder app)&#10;    {&#10;        var group = app.MapGroup(&quot;/auth&quot;).WithTags(&quot;Authentication&quot;);&#10;&#10;        // Login endpoint - PÚBLICO (sin restricciones de seguridad)&#10;        group.MapPost(&quot;/login&quot;, async (LoginRequest request, IAuthService authService) =&gt;&#10;        {&#10;            if (string.IsNullOrEmpty(request.Email) || string.IsNullOrEmpty(request.Password))&#10;            {&#10;                return Results.BadRequest(new AuthResponse&#10;                {&#10;                    IsSuccess = false,&#10;                    ErrorMessage = &quot;Email y contraseña son requeridos&quot;&#10;                });&#10;            }&#10;&#10;            var result = await authService.LoginAsync(request.Email, request.Password);&#10;            &#10;            if (!result.IsSuccess)&#10;            {&#10;                return Results.Unauthorized();&#10;            }&#10;&#10;            var response = new AuthResponse&#10;            {&#10;                IsSuccess = true,&#10;                Token = result.Token,&#10;                RefreshToken = result.RefreshToken,&#10;                ExpiresAt = result.ExpiresAt,&#10;                User = new UserInfoResponse&#10;                {&#10;                    Id = result.User!.Id,&#10;                    Email = result.User.Email,&#10;                    Nombre = result.User.Nombre,&#10;                    Apellido = result.User.Apellido,&#10;                    TipoUsuario = result.User.Rol.ToString(),&#10;                    Telefono = result.User.Telefono,&#10;                    FechaAlta = result.User.FechaAlta&#10;                }&#10;            };&#10;&#10;            return Results.Ok(response);&#10;        })&#10;        .AllowAnonymous()&#10;        .WithName(&quot;Login&quot;)&#10;        .WithSummary(&quot;Iniciar sesión&quot;)&#10;        .WithDescription(&quot;Autentica un usuario y retorna un token JWT. Endpoint público sin restricciones de seguridad.&quot;)&#10;        .Produces&lt;AuthResponse&gt;(200)&#10;        .Produces(401)&#10;        .Produces(400);&#10;&#10;        // Register endpoint - SOLO ADMINS&#10;        group.MapPost(&quot;/register&quot;, async (RegisterRequest request, IAuthService authService) =&gt;&#10;        {&#10;            if (string.IsNullOrEmpty(request.Email) || string.IsNullOrEmpty(request.Password) ||&#10;                string.IsNullOrEmpty(request.Nombre) || string.IsNullOrEmpty(request.Apellido))&#10;            {&#10;                return Results.BadRequest(new AuthResponse&#10;                {&#10;                    IsSuccess = false,&#10;                    ErrorMessage = &quot;Email, contraseña, nombre y apellido son requeridos&quot;&#10;                });&#10;            }&#10;&#10;            if (request.Password != request.ConfirmPassword)&#10;            {&#10;                return Results.BadRequest(new AuthResponse&#10;                {&#10;                    IsSuccess = false,&#10;                    ErrorMessage = &quot;Las contraseñas no coinciden&quot;&#10;                });&#10;            }&#10;&#10;            var result = await authService.RegisterAsync(&#10;                request.Email,&#10;                request.Password,&#10;                request.Nombre,&#10;                request.Apellido,&#10;                request.Telefono,&#10;                request.Rol&#10;            );&#10;            &#10;            if (!result.IsSuccess)&#10;            {&#10;                return Results.BadRequest(new AuthResponse&#10;                {&#10;                    IsSuccess = false,&#10;                    ErrorMessage = result.ErrorMessage ?? &quot;Error al registrar el usuario&quot;&#10;                });&#10;            }&#10;&#10;            var response = new AuthResponse&#10;            {&#10;                IsSuccess = true,&#10;                Token = result.Token,&#10;                RefreshToken = result.RefreshToken,&#10;                ExpiresAt = result.ExpiresAt,&#10;                User = new UserInfoResponse&#10;                {&#10;                    Id = result.User!.Id,&#10;                    Email = result.User.Email,&#10;                    Nombre = result.User.Nombre,&#10;                    Apellido = result.User.Apellido,&#10;                    TipoUsuario = result.User.Rol.ToString(),&#10;                    Telefono = result.User.Telefono,&#10;                    FechaAlta = result.User.FechaAlta&#10;                }&#10;            };&#10;&#10;            return Results.Ok(response);&#10;        })&#10;        .WithName(&quot;Register&quot;)&#10;        .WithSummary(&quot;Registrar nuevo usuario&quot;)&#10;        .WithDescription(&quot;Registra un nuevo usuario en el sistema. Solo accesible por Administradores.&quot;)&#10;        .Produces&lt;AuthResponse&gt;(200)&#10;        .Produces(400)&#10;        .Produces(401)&#10;        .RequireAuthorization(&quot;AdminOnly&quot;);&#10;&#10;        // Generar código QR con el JWT actual&#10;        group.MapGet(&quot;/qr&quot;, (&#10;            HttpContext httpContext,&#10;            QrCodeGenerator qr&#10;        ) =&gt;&#10;        {&#10;            // 1) Permitir token explícito por query: /auth/qr?token=...&#10;            string? token = httpContext.Request.Query[&quot;token&quot;];&#10;&#10;            // 2) Si no viene por query, intentar extraer del header Authorization: Bearer &lt;token&gt;&#10;            if (string.IsNullOrWhiteSpace(token))&#10;            {&#10;                if (httpContext.Request.Headers.TryGetValue(&quot;Authorization&quot;, out var authHeader))&#10;                {&#10;                    var value = authHeader.ToString();&#10;                    const string prefix = &quot;Bearer &quot;;&#10;                    if (value.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))&#10;                    {&#10;                        token = value.Substring(prefix.Length).Trim();&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (string.IsNullOrWhiteSpace(token))&#10;            {&#10;                return Results.BadRequest(new { message = &quot;Falta el token JWT (use query 'token' o Authorization: Bearer ...)&quot; });&#10;            }&#10;&#10;            // Generar PNG con el token (solo Windows por dependencia de System.Drawing)&#10;            if (!OperatingSystem.IsWindows())&#10;            {&#10;                return Results.Problem(&quot;Generación de QR no soportada en esta plataforma (requiere Windows)&quot;, statusCode: 501);&#10;            }&#10;&#10;            // Tamaño opcional del QR: ?w=250&amp;h=250&#10;            int w = 250;&#10;            int h = 250;&#10;            if (int.TryParse(httpContext.Request.Query[&quot;w&quot;], out var wParsed) &amp;&amp; wParsed &gt; 0)&#10;            {&#10;                w = wParsed;&#10;            }&#10;            if (int.TryParse(httpContext.Request.Query[&quot;h&quot;], out var hParsed) &amp;&amp; hParsed &gt; 0)&#10;            {&#10;                h = hParsed;&#10;            }&#10;&#10;            var pngBytes = qr.Generate(token, w, h);&#10;            return Results.File(pngBytes, contentType: &quot;image/png&quot;, fileDownloadName: null, enableRangeProcessing: false);&#10;        })&#10;        .WithName(&quot;GetAuthTokenQr&quot;)&#10;        .WithSummary(&quot;Generar código QR del JWT&quot;)&#10;        .WithDescription(&quot;Devuelve una imagen PNG con el QR que contiene el token JWT. Acepta query 'token' o usa el header Authorization.&quot;)&#10;        .Produces(200)&#10;        .Produces(400)&#10;        .RequireAuthorization();&#10;&#10;        // Crear usuarios de prueba - PÚBLICO (para testing)&#10;        group.MapPost(&quot;/create-test-users&quot;, async (&#10;            IUsuarioFactory factory, &#10;            IUsuarioRepository repo,&#10;            IPasswordService passwordService) =&gt;&#10;        {&#10;            var usuariosCreados = new List&lt;object&gt;();&#10;            var usuariosExistentes = new List&lt;object&gt;();&#10;            var totalCreados = 0;&#10;            var totalExistentes = 0;&#10;&#10;            // Datos de usuarios de prueba con contraseñas en texto plano&#10;            var usuariosTest = new[]&#10;            {&#10;                // Administradores&#10;                new { Email = &quot;admin1@gatekeep.com&quot;, Nombre = &quot;Admin&quot;, Apellido = &quot;Uno&quot;, Telefono = &quot;+1234567891&quot;, Password = &quot;admin123&quot;, Tipo = &quot;Admin&quot; },&#10;                new { Email = &quot;admin2@gatekeep.com&quot;, Nombre = &quot;Admin&quot;, Apellido = &quot;Dos&quot;, Telefono = &quot;+1234567892&quot;, Password = &quot;admin123&quot;, Tipo = &quot;Admin&quot; },&#10;                new { Email = &quot;admin3@gatekeep.com&quot;, Nombre = &quot;Admin&quot;, Apellido = &quot;Tres&quot;, Telefono = &quot;+1234567893&quot;, Password = &quot;admin123&quot;, Tipo = &quot;Admin&quot; },&#10;                &#10;                // Estudiantes&#10;                new { Email = &quot;estudiante1@gatekeep.com&quot;, Nombre = &quot;Juan&quot;, Apellido = &quot;Pérez&quot;, Telefono = &quot;+1234567894&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#10;                new { Email = &quot;estudiante2@gatekeep.com&quot;, Nombre = &quot;María&quot;, Apellido = &quot;García&quot;, Telefono = &quot;+1234567895&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#10;                new { Email = &quot;estudiante3@gatekeep.com&quot;, Nombre = &quot;Carlos&quot;, Apellido = &quot;López&quot;, Telefono = &quot;+1234567896&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#10;                new { Email = &quot;estudiante4@gatekeep.com&quot;, Nombre = &quot;Ana&quot;, Apellido = &quot;Martínez&quot;, Telefono = &quot;+1234567897&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#10;                new { Email = &quot;estudiante5@gatekeep.com&quot;, Nombre = &quot;Luis&quot;, Apellido = &quot;Rodríguez&quot;, Telefono = &quot;+1234567898&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#10;                &#10;                // Funcionarios&#10;                new { Email = &quot;funcionario1@gatekeep.com&quot;, Nombre = &quot;Roberto&quot;, Apellido = &quot;Silva&quot;, Telefono = &quot;+1234567899&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; },&#10;                new { Email = &quot;funcionario2@gatekeep.com&quot;, Nombre = &quot;Patricia&quot;, Apellido = &quot;Morales&quot;, Telefono = &quot;+1234567900&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; },&#10;                new { Email = &quot;funcionario3@gatekeep.com&quot;, Nombre = &quot;Fernando&quot;, Apellido = &quot;Castro&quot;, Telefono = &quot;+1234567901&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; },&#10;                new { Email = &quot;funcionario4@gatekeep.com&quot;, Nombre = &quot;Isabel&quot;, Apellido = &quot;Vargas&quot;, Telefono = &quot;+1234567902&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; }&#10;            };&#10;&#10;            foreach (var usuarioTest in usuariosTest)&#10;            {&#10;                var existing = await repo.GetByEmailAsync(usuarioTest.Email);&#10;                if (existing == null)&#10;                {&#10;                    // Crear usuario nuevo&#10;                    var usuarioDto = new UsuarioDto&#10;                    {&#10;                        Email = usuarioTest.Email,&#10;                        Nombre = usuarioTest.Nombre,&#10;                        Apellido = usuarioTest.Apellido,&#10;                        Contrasenia = passwordService.HashPassword(usuarioTest.Password),&#10;                        Telefono = usuarioTest.Telefono,&#10;                        Rol = usuarioTest.Tipo switch&#10;                        {&#10;                            &quot;Admin&quot; =&gt; GateKeep.Api.Domain.Enums.Rol.Admin,&#10;                            &quot;Estudiante&quot; =&gt; GateKeep.Api.Domain.Enums.Rol.Estudiante,&#10;                            &quot;Funcionario&quot; =&gt; GateKeep.Api.Domain.Enums.Rol.Funcionario,&#10;                            _ =&gt; GateKeep.Api.Domain.Enums.Rol.Estudiante&#10;                        }&#10;                    };&#10;&#10;                    var usuario = factory.CrearUsuario(usuarioDto);&#10;&#10;                    await repo.AddAsync(usuario);&#10;                    usuariosCreados.Add(new { &#10;                        Tipo = usuarioTest.Tipo, &#10;                        Id = usuario.Id, &#10;                        Email = usuario.Email, &#10;                        Nombre = usuario.Nombre, &#10;                        Apellido = usuario.Apellido,&#10;                        Password = usuarioTest.Password,&#10;                        Telefono = usuario.Telefono&#10;                    });&#10;                    totalCreados++;&#10;                }&#10;                else&#10;                {&#10;                    // Usuario ya existe - agregar a lista de existentes&#10;                    usuariosExistentes.Add(new { &#10;                        Tipo = usuarioTest.Tipo, &#10;                        Id = existing.Id, &#10;                        Email = existing.Email, &#10;                        Nombre = existing.Nombre, &#10;                        Apellido = existing.Apellido,&#10;                        Password = usuarioTest.Password,&#10;                        Telefono = existing.Telefono&#10;                    });&#10;                    totalExistentes++;&#10;                }&#10;            }&#10;&#10;            return Results.Ok(new&#10;            {&#10;                IsSuccess = true,&#10;                Message = $&quot;Proceso completado. Creados: {totalCreados}, Existentes: {totalExistentes}&quot;,&#10;                UsuariosCreados = usuariosCreados,&#10;                UsuariosExistentes = usuariosExistentes,&#10;                Resumen = new&#10;                {&#10;                    TotalCreados = totalCreados,&#10;                    TotalExistentes = totalExistentes,&#10;                    TotalProcesados = totalCreados + totalExistentes&#10;                }&#10;            });&#10;        })&#10;        .WithName(&quot;CreateTestUsers&quot;)&#10;        .WithSummary(&quot;Crear usuarios de prueba&quot;)&#10;        .WithDescription(&quot;Crea usuarios de prueba de todos los tipos para testing&quot;)&#10;        .Produces&lt;AuthResponse&gt;(200)&#10;        .Produces(400);&#10;&#10;        // Endpoint para listar usuarios con contraseñas en texto plano&#10;        group.MapGet(&quot;/list-users&quot;, async (IUsuarioRepository repo) =&gt;&#10;        {&#10;            var usuarios = await repo.GetAllAsync();&#10;            &#10;            // Mapear usuarios con contraseñas en texto plano para testing&#10;            var usuariosConPasswords = usuarios.Select(u =&gt; new&#10;            {&#10;                Id = u.Id,&#10;                Email = u.Email,&#10;                Nombre = u.Nombre,&#10;                Apellido = u.Apellido,&#10;                Telefono = u.Telefono,&#10;                TipoUsuario = u.Rol.ToString(),&#10;                FechaAlta = u.FechaAlta,&#10;                Credencial = u.Credencial,&#10;                // Contraseñas en texto plano para testing (solo para desarrollo)&#10;                Password = GetPasswordForTesting(u.Email)&#10;            }).ToList();&#10;&#10;            return Results.Ok(new&#10;            {&#10;                IsSuccess = true,&#10;                Message = $&quot;Se encontraron {usuariosConPasswords.Count} usuarios&quot;,&#10;                TotalUsuarios = usuariosConPasswords.Count,&#10;                Usuarios = usuariosConPasswords&#10;            });&#10;        })&#10;        .WithName(&quot;ListUsers&quot;)&#10;        .WithSummary(&quot;Listar usuarios&quot;)&#10;        .WithDescription(&quot;Lista todos los usuarios con contraseñas en texto plano para testing&quot;)&#10;        .Produces(200)&#10;        .Produces(400);&#10;&#10;        return app;&#10;    }&#10;&#10;    // Método auxiliar para obtener contraseñas de testing&#10;    private static string GetPasswordForTesting(string email)&#10;    {&#10;        // Mapeo de contraseñas para testing basado en el email&#10;        return email switch&#10;        {&#10;            var e when e.Contains(&quot;admin&quot;) =&gt; &quot;admin123&quot;,&#10;            var e when e.Contains(&quot;estudiante&quot;) =&gt; &quot;estudiante123&quot;,&#10;            var e when e.Contains(&quot;funcionario&quot;) =&gt; &quot;funcionario123&quot;,&#10;            _ =&gt; &quot;password123&quot; // Contraseña por defecto&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using GateKeep.Api.Contracts.Security;&#13;&#10;using GateKeep.Api.Contracts.Usuarios;&#13;&#10;using GateKeep.Api.Application.Security;&#13;&#10;using GateKeep.Api.Application.Usuarios;&#13;&#10;using GateKeep.Infrastructure.QrCodes;&#13;&#10;using System.Security.Claims;&#13;&#10;&#13;&#10;namespace GateKeep.Api.Endpoints.Auth;&#13;&#10;&#13;&#10;public static class AuthEndpoints&#13;&#10;{&#13;&#10;    public static IEndpointRouteBuilder MapAuthEndpoints(this IEndpointRouteBuilder app)&#13;&#10;    {&#13;&#10;        var group = app.MapGroup(&quot;/auth&quot;).WithTags(&quot;Authentication&quot;);&#13;&#10;&#13;&#10;        // Login endpoint - PÚBLICO (sin restricciones de seguridad)&#13;&#10;        group.MapPost(&quot;/login&quot;, async (LoginRequest request, IAuthService authService) =&gt;&#13;&#10;        {&#13;&#10;            if (string.IsNullOrEmpty(request.Email) || string.IsNullOrEmpty(request.Password))&#13;&#10;            {&#13;&#10;                return Results.BadRequest(new AuthResponse&#13;&#10;                {&#13;&#10;                    IsSuccess = false,&#13;&#10;                    ErrorMessage = &quot;Email y contraseña son requeridos&quot;&#13;&#10;                });&#13;&#10;            }&#13;&#10;&#13;&#10;            var result = await authService.LoginAsync(request.Email, request.Password);&#13;&#10;            &#13;&#10;            if (!result.IsSuccess)&#13;&#10;            {&#13;&#10;                return Results.Unauthorized();&#13;&#10;            }&#13;&#10;&#13;&#10;            var response = new AuthResponse&#13;&#10;            {&#13;&#10;                IsSuccess = true,&#13;&#10;                Token = result.Token,&#13;&#10;                RefreshToken = result.RefreshToken,&#13;&#10;                ExpiresAt = result.ExpiresAt,&#13;&#10;                User = new UserInfoResponse&#13;&#10;                {&#13;&#10;                    Id = result.User!.Id,&#13;&#10;                    Email = result.User.Email,&#13;&#10;                    Nombre = result.User.Nombre,&#13;&#10;                    Apellido = result.User.Apellido,&#13;&#10;                    TipoUsuario = result.User.Rol.ToString(),&#13;&#10;                    Telefono = result.User.Telefono,&#13;&#10;                    FechaAlta = result.User.FechaAlta&#13;&#10;                }&#13;&#10;            };&#13;&#10;&#13;&#10;            return Results.Ok(response);&#13;&#10;        })&#13;&#10;        .AllowAnonymous()&#13;&#10;        .WithName(&quot;Login&quot;)&#13;&#10;        .WithSummary(&quot;Iniciar sesión&quot;)&#13;&#10;        .WithDescription(&quot;Autentica un usuario y retorna un token JWT. Endpoint público sin restricciones de seguridad.&quot;)&#13;&#10;        .Produces&lt;AuthResponse&gt;(200)&#13;&#10;        .Produces(401)&#13;&#10;        .Produces(400);&#13;&#10;&#13;&#10;        // Register endpoint - SOLO ADMINS&#13;&#10;        group.MapPost(&quot;/register&quot;, async (RegisterRequest request, IAuthService authService) =&gt;&#13;&#10;        {&#13;&#10;            if (string.IsNullOrEmpty(request.Email) || string.IsNullOrEmpty(request.Password) ||&#13;&#10;                string.IsNullOrEmpty(request.Nombre) || string.IsNullOrEmpty(request.Apellido))&#13;&#10;            {&#13;&#10;                return Results.BadRequest(new AuthResponse&#13;&#10;                {&#13;&#10;                    IsSuccess = false,&#13;&#10;                    ErrorMessage = &quot;Email, contraseña, nombre y apellido son requeridos&quot;&#13;&#10;                });&#13;&#10;            }&#13;&#10;&#13;&#10;            if (request.Password != request.ConfirmPassword)&#13;&#10;            {&#13;&#10;                return Results.BadRequest(new AuthResponse&#13;&#10;                {&#13;&#10;                    IsSuccess = false,&#13;&#10;                    ErrorMessage = &quot;Las contraseñas no coinciden&quot;&#13;&#10;                });&#13;&#10;            }&#13;&#10;&#13;&#10;            var result = await authService.RegisterAsync(&#13;&#10;                request.Email,&#13;&#10;                request.Password,&#13;&#10;                request.Nombre,&#13;&#10;                request.Apellido,&#13;&#10;                request.Telefono,&#13;&#10;                request.Rol&#13;&#10;            );&#13;&#10;            &#13;&#10;            if (!result.IsSuccess)&#13;&#10;            {&#13;&#10;                return Results.BadRequest(new AuthResponse&#13;&#10;                {&#13;&#10;                    IsSuccess = false,&#13;&#10;                    ErrorMessage = result.ErrorMessage ?? &quot;Error al registrar el usuario&quot;&#13;&#10;                });&#13;&#10;            }&#13;&#10;&#13;&#10;            var response = new AuthResponse&#13;&#10;            {&#13;&#10;                IsSuccess = true,&#13;&#10;                Token = result.Token,&#13;&#10;                RefreshToken = result.RefreshToken,&#13;&#10;                ExpiresAt = result.ExpiresAt,&#13;&#10;                User = new UserInfoResponse&#13;&#10;                {&#13;&#10;                    Id = result.User!.Id,&#13;&#10;                    Email = result.User.Email,&#13;&#10;                    Nombre = result.User.Nombre,&#13;&#10;                    Apellido = result.User.Apellido,&#13;&#10;                    TipoUsuario = result.User.Rol.ToString(),&#13;&#10;                    Telefono = result.User.Telefono,&#13;&#10;                    FechaAlta = result.User.FechaAlta&#13;&#10;                }&#13;&#10;            };&#13;&#10;&#13;&#10;            return Results.Ok(response);&#13;&#10;        })&#13;&#10;        .WithName(&quot;Register&quot;)&#13;&#10;        .WithSummary(&quot;Registrar nuevo usuario&quot;)&#13;&#10;        .WithDescription(&quot;Registra un nuevo usuario en el sistema. Solo accesible por Administradores.&quot;)&#13;&#10;        .Produces&lt;AuthResponse&gt;(200)&#13;&#10;        .Produces(400)&#13;&#10;        .Produces(401)&#13;&#10;        .RequireAuthorization(&quot;AdminOnly&quot;);&#13;&#10;&#13;&#10;        // Generar código QR con el JWT actual&#13;&#10;        group.MapGet(&quot;/qr&quot;, (&#13;&#10;            HttpContext httpContext,&#13;&#10;            QrCodeGenerator qr&#13;&#10;        ) =&gt;&#13;&#10;        {&#13;&#10;            // 1) Permitir token explícito por query: /auth/qr?token=...&#13;&#10;            string? token = httpContext.Request.Query[&quot;token&quot;];&#13;&#10;&#13;&#10;            // 2) Si no viene por query, intentar extraer del header Authorization: Bearer &lt;token&gt;&#13;&#10;            if (string.IsNullOrWhiteSpace(token))&#13;&#10;            {&#13;&#10;                if (httpContext.Request.Headers.TryGetValue(&quot;Authorization&quot;, out var authHeader))&#13;&#10;                {&#13;&#10;                    var value = authHeader.ToString();&#13;&#10;                    const string prefix = &quot;Bearer &quot;;&#13;&#10;                    if (value.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))&#13;&#10;                    {&#13;&#10;                        token = value.Substring(prefix.Length).Trim();&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            if (string.IsNullOrWhiteSpace(token))&#13;&#10;            {&#13;&#10;                return Results.BadRequest(new { message = &quot;Falta el token JWT (use query 'token' o Authorization: Bearer ...)&quot; });&#13;&#10;            }&#13;&#10;&#13;&#10;            // Generar PNG con el token (solo Windows por dependencia de System.Drawing)&#13;&#10;            if (!OperatingSystem.IsWindows())&#13;&#10;            {&#13;&#10;                return Results.Problem(&quot;Generación de QR no soportada en esta plataforma (requiere Windows)&quot;, statusCode: 501);&#13;&#10;            }&#13;&#10;&#13;&#10;            // Tamaño opcional del QR: ?w=250&amp;h=250&#13;&#10;            int w = 250;&#13;&#10;            int h = 250;&#13;&#10;            if (int.TryParse(httpContext.Request.Query[&quot;w&quot;], out var wParsed) &amp;&amp; wParsed &gt; 0)&#13;&#10;            {&#13;&#10;                w = wParsed;&#13;&#10;            }&#13;&#10;            if (int.TryParse(httpContext.Request.Query[&quot;h&quot;], out var hParsed) &amp;&amp; hParsed &gt; 0)&#13;&#10;            {&#13;&#10;                h = hParsed;&#13;&#10;            }&#13;&#10;&#13;&#10;            var pngBytes = qr.Generate(token, w, h);&#13;&#10;            return Results.File(pngBytes, contentType: &quot;image/png&quot;, fileDownloadName: null, enableRangeProcessing: false);&#13;&#10;        })&#13;&#10;        .WithName(&quot;GetAuthTokenQr&quot;)&#13;&#10;        .WithSummary(&quot;Generar código QR del JWT&quot;)&#13;&#10;        .WithDescription(&quot;Devuelve una imagen PNG con el QR que contiene el token JWT. Acepta query 'token' o usa el header Authorization.&quot;)&#13;&#10;        .Produces(200)&#13;&#10;        .Produces(400)&#13;&#10;        .RequireAuthorization();&#13;&#10;&#13;&#10;        // Crear usuarios de prueba - PÚBLICO (para testing)&#13;&#10;        group.MapPost(&quot;/create-test-users&quot;, async (&#13;&#10;            IUsuarioFactory factory, &#13;&#10;            IUsuarioRepository repo,&#13;&#10;            IPasswordService passwordService) =&gt;&#13;&#10;        {&#13;&#10;            var usuariosCreados = new List&lt;object&gt;();&#13;&#10;            var usuariosExistentes = new List&lt;object&gt;();&#13;&#10;            var totalCreados = 0;&#13;&#10;            var totalExistentes = 0;&#13;&#10;&#13;&#10;            // Datos de usuarios de prueba con contraseñas en texto plano&#13;&#10;            var usuariosTest = new[]&#13;&#10;            {&#13;&#10;                // Administradores&#13;&#10;                new { Email = &quot;admin1@gatekeep.com&quot;, Nombre = &quot;Admin&quot;, Apellido = &quot;Uno&quot;, Telefono = &quot;+1234567891&quot;, Password = &quot;admin123&quot;, Tipo = &quot;Admin&quot; },&#13;&#10;                new { Email = &quot;admin2@gatekeep.com&quot;, Nombre = &quot;Admin&quot;, Apellido = &quot;Dos&quot;, Telefono = &quot;+1234567892&quot;, Password = &quot;admin123&quot;, Tipo = &quot;Admin&quot; },&#13;&#10;                new { Email = &quot;admin3@gatekeep.com&quot;, Nombre = &quot;Admin&quot;, Apellido = &quot;Tres&quot;, Telefono = &quot;+1234567893&quot;, Password = &quot;admin123&quot;, Tipo = &quot;Admin&quot; },&#13;&#10;                &#13;&#10;                // Estudiantes&#13;&#10;                new { Email = &quot;estudiante1@gatekeep.com&quot;, Nombre = &quot;Juan&quot;, Apellido = &quot;Pérez&quot;, Telefono = &quot;+1234567894&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#13;&#10;                new { Email = &quot;estudiante2@gatekeep.com&quot;, Nombre = &quot;María&quot;, Apellido = &quot;García&quot;, Telefono = &quot;+1234567895&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#13;&#10;                new { Email = &quot;estudiante3@gatekeep.com&quot;, Nombre = &quot;Carlos&quot;, Apellido = &quot;López&quot;, Telefono = &quot;+1234567896&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#13;&#10;                new { Email = &quot;estudiante4@gatekeep.com&quot;, Nombre = &quot;Ana&quot;, Apellido = &quot;Martínez&quot;, Telefono = &quot;+1234567897&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#13;&#10;                new { Email = &quot;estudiante5@gatekeep.com&quot;, Nombre = &quot;Luis&quot;, Apellido = &quot;Rodríguez&quot;, Telefono = &quot;+1234567898&quot;, Password = &quot;estudiante123&quot;, Tipo = &quot;Estudiante&quot; },&#13;&#10;                &#13;&#10;                // Funcionarios&#13;&#10;                new { Email = &quot;funcionario1@gatekeep.com&quot;, Nombre = &quot;Roberto&quot;, Apellido = &quot;Silva&quot;, Telefono = &quot;+1234567899&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; },&#13;&#10;                new { Email = &quot;funcionario2@gatekeep.com&quot;, Nombre = &quot;Patricia&quot;, Apellido = &quot;Morales&quot;, Telefono = &quot;+1234567900&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; },&#13;&#10;                new { Email = &quot;funcionario3@gatekeep.com&quot;, Nombre = &quot;Fernando&quot;, Apellido = &quot;Castro&quot;, Telefono = &quot;+1234567901&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; },&#13;&#10;                new { Email = &quot;funcionario4@gatekeep.com&quot;, Nombre = &quot;Isabel&quot;, Apellido = &quot;Vargas&quot;, Telefono = &quot;+1234567902&quot;, Password = &quot;funcionario123&quot;, Tipo = &quot;Funcionario&quot; }&#13;&#10;            };&#13;&#10;&#13;&#10;            foreach (var usuarioTest in usuariosTest)&#13;&#10;            {&#13;&#10;                var existing = await repo.GetByEmailAsync(usuarioTest.Email);&#13;&#10;                if (existing == null)&#13;&#10;                {&#13;&#10;                    // Crear usuario nuevo&#13;&#10;                    var usuarioDto = new UsuarioDto&#13;&#10;                    {&#13;&#10;                        Email = usuarioTest.Email,&#13;&#10;                        Nombre = usuarioTest.Nombre,&#13;&#10;                        Apellido = usuarioTest.Apellido,&#13;&#10;                        Contrasenia = passwordService.HashPassword(usuarioTest.Password),&#13;&#10;                        Telefono = usuarioTest.Telefono,&#13;&#10;                        Rol = usuarioTest.Tipo switch&#13;&#10;                        {&#13;&#10;                            &quot;Admin&quot; =&gt; GateKeep.Api.Domain.Enums.Rol.Admin,&#13;&#10;                            &quot;Estudiante&quot; =&gt; GateKeep.Api.Domain.Enums.Rol.Estudiante,&#13;&#10;                            &quot;Funcionario&quot; =&gt; GateKeep.Api.Domain.Enums.Rol.Funcionario,&#13;&#10;                            _ =&gt; GateKeep.Api.Domain.Enums.Rol.Estudiante&#13;&#10;                        }&#13;&#10;                    };&#13;&#10;&#13;&#10;                    var usuario = factory.CrearUsuario(usuarioDto);&#13;&#10;&#13;&#10;                    await repo.AddAsync(usuario);&#13;&#10;                    usuariosCreados.Add(new { &#13;&#10;                        Tipo = usuarioTest.Tipo, &#13;&#10;                        Id = usuario.Id, &#13;&#10;                        Email = usuario.Email, &#13;&#10;                        Nombre = usuario.Nombre, &#13;&#10;                        Apellido = usuario.Apellido,&#13;&#10;                        Password = usuarioTest.Password,&#13;&#10;                        Telefono = usuario.Telefono&#13;&#10;                    });&#13;&#10;                    totalCreados++;&#13;&#10;                }&#13;&#10;                else&#13;&#10;                {&#13;&#10;                    // Usuario ya existe - agregar a lista de existentes&#13;&#10;                    usuariosExistentes.Add(new { &#13;&#10;                        Tipo = usuarioTest.Tipo, &#13;&#10;                        Id = existing.Id, &#13;&#10;                        Email = existing.Email, &#13;&#10;                        Nombre = existing.Nombre, &#13;&#10;                        Apellido = existing.Apellido,&#13;&#10;                        Password = usuarioTest.Password,&#13;&#10;                        Telefono = existing.Telefono&#13;&#10;                    });&#13;&#10;                    totalExistentes++;&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            return Results.Ok(new&#13;&#10;            {&#13;&#10;                IsSuccess = true,&#13;&#10;                Message = $&quot;Proceso completado. Creados: {totalCreados}, Existentes: {totalExistentes}&quot;,&#13;&#10;                UsuariosCreados = usuariosCreados,&#13;&#10;                UsuariosExistentes = usuariosExistentes,&#13;&#10;                Resumen = new&#13;&#10;                {&#13;&#10;                    TotalCreados = totalCreados,&#13;&#10;                    TotalExistentes = totalExistentes,&#13;&#10;                    TotalProcesados = totalCreados + totalExistentes&#13;&#10;                }&#13;&#10;            });&#13;&#10;        })&#13;&#10;        .WithName(&quot;CreateTestUsers&quot;)&#13;&#10;        .WithSummary(&quot;Crear usuarios de prueba&quot;)&#13;&#10;        .WithDescription(&quot;Crea usuarios de prueba de todos los tipos para testing&quot;)&#13;&#10;        .Produces&lt;AuthResponse&gt;(200)&#13;&#10;        .Produces(400);&#13;&#10;&#13;&#10;        // Endpoint para listar usuarios con contraseñas en texto plano&#13;&#10;        group.MapGet(&quot;/list-users&quot;, async (IUsuarioRepository repo) =&gt;&#13;&#10;        {&#13;&#10;            var usuarios = await repo.GetAllAsync();&#13;&#10;            &#13;&#10;            // Mapear usuarios con contraseñas en texto plano para testing&#13;&#10;            var usuariosConPasswords = usuarios.Select(u =&gt; new&#13;&#10;            {&#13;&#10;                Id = u.Id,&#13;&#10;                Email = u.Email,&#13;&#10;                Nombre = u.Nombre,&#13;&#10;                Apellido = u.Apellido,&#13;&#10;                Telefono = u.Telefono,&#13;&#10;                TipoUsuario = u.Rol.ToString(),&#13;&#10;                FechaAlta = u.FechaAlta,&#13;&#10;                Credencial = u.Credencial,&#13;&#10;                // Contraseñas en texto plano para testing (solo para desarrollo)&#13;&#10;                Password = GetPasswordForTesting(u.Email)&#13;&#10;            }).ToList();&#13;&#10;&#13;&#10;            return Results.Ok(new&#13;&#10;            {&#13;&#10;                IsSuccess = true,&#13;&#10;                Message = $&quot;Se encontraron {usuariosConPasswords.Count} usuarios&quot;,&#13;&#10;                TotalUsuarios = usuariosConPasswords.Count,&#13;&#10;                Usuarios = usuariosConPasswords&#13;&#10;            });&#13;&#10;        })&#13;&#10;        .WithName(&quot;ListUsers&quot;)&#13;&#10;        .WithSummary(&quot;Listar usuarios&quot;)&#13;&#10;        .WithDescription(&quot;Lista todos los usuarios con contraseñas en texto plano para testing&quot;)&#13;&#10;        .Produces(200)&#13;&#10;        .Produces(400);&#13;&#10;&#13;&#10;        return app;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Método auxiliar para obtener contraseñas de testing&#13;&#10;    private static string GetPasswordForTesting(string email)&#13;&#10;    {&#13;&#10;        // Mapeo de contraseñas para testing basado en el email&#13;&#10;        return email switch&#13;&#10;        {&#13;&#10;            var e when e.Contains(&quot;admin&quot;) =&gt; &quot;admin123&quot;,&#13;&#10;            var e when e.Contains(&quot;estudiante&quot;) =&gt; &quot;estudiante123&quot;,&#13;&#10;            var e when e.Contains(&quot;funcionario&quot;) =&gt; &quot;funcionario123&quot;,&#13;&#10;            _ =&gt; &quot;password123&quot; // Contraseña por defecto&#13;&#10;        };&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/GateKeep.Api/GateKeep.Api.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/GateKeep.Api/GateKeep.Api.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;    &lt;RootNamespace&gt;GateKeep.Api&lt;/RootNamespace&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;MassTransit&quot; Version=&quot;8.2.5&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;MassTransit.RabbitMQ&quot; Version=&quot;8.2.5&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.OpenApi&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.Design&quot; Version=&quot;8.*&quot;&gt;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;    &lt;/PackageReference&gt;&#10;    &lt;PackageReference Include=&quot;MongoDB.Driver&quot; Version=&quot;3.5.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Npgsql.EntityFrameworkCore.PostgreSQL&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;6.*&quot; /&gt;&#10;    &#10;    &lt;!-- Paquetes de Seguridad --&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.JwtBearer&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authorization&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;System.Drawing.Common&quot; Version=&quot;9.0.10&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;System.IdentityModel.Tokens.Jwt&quot; Version=&quot;7.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;BCrypt.Net-Next&quot; Version=&quot;4.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;ZXing.Net&quot; Version=&quot;0.16.11&quot; /&gt;&#10;    &lt;!-- Binding para soporte de System.Drawing (BitmapRenderer, BarcodeWriter&lt;Bitmap&gt;) --&gt;&#10;    &lt;PackageReference Include=&quot;ZXing.Net.Bindings.Windows.Compatibility&quot; Version=&quot;0.16.14&quot; /&gt;&#10;    &#10;    &lt;!-- Paquetes de Redis para Caching --&gt;&#10;    &lt;PackageReference Include=&quot;StackExchange.Redis&quot; Version=&quot;2.8.16&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.Extensions.Caching.StackExchangeRedis&quot; Version=&quot;8.*&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;Folder Include=&quot;Application\&quot; /&gt;&#10;    &lt;Folder Include=&quot;Contacts\&quot; /&gt;&#10;    &lt;Folder Include=&quot;Domain\&quot; /&gt;&#10;    &lt;Folder Include=&quot;Endpoints\&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;!-- Target para limpiar antes del build (solo en Debug) --&gt;&#10;  &lt;!-- Nota: Este target limpia los archivos de salida antes de compilar --&gt;&#10;  &lt;Target Name=&quot;PreBuildClean&quot; BeforeTargets=&quot;BeforeBuild&quot; Condition=&quot;'$(Configuration)' == 'Debug'&quot;&gt;&#10;    &lt;Message Text=&quot;Limpiando archivos de salida antes del build...&quot; Importance=&quot;high&quot; /&gt;&#10;    &lt;ItemGroup&gt;&#10;      &lt;FilesToDelete Include=&quot;$(OutputPath)**\*.*&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;    &lt;Delete Files=&quot;@(FilesToDelete)&quot; ContinueOnError=&quot;true&quot; /&gt;&#10;    &lt;Message Text=&quot;Clean completado. Iniciando build...&quot; Importance=&quot;high&quot; /&gt;&#10;  &lt;/Target&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;&#13;&#10;&#13;&#10;  &lt;PropertyGroup&gt;&#13;&#10;    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#13;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#13;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#13;&#10;    &lt;RootNamespace&gt;GateKeep.Api&lt;/RootNamespace&gt;&#13;&#10;  &lt;/PropertyGroup&gt;&#13;&#10;&#13;&#10;  &lt;ItemGroup&gt;&#13;&#10;    &lt;PackageReference Include=&quot;MassTransit&quot; Version=&quot;8.2.5&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;MassTransit.RabbitMQ&quot; Version=&quot;8.2.5&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.OpenApi&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.Design&quot; Version=&quot;8.*&quot;&gt;&#13;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#13;&#10;      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#13;&#10;    &lt;/PackageReference&gt;&#13;&#10;    &lt;PackageReference Include=&quot;MongoDB.Driver&quot; Version=&quot;3.5.0&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Npgsql.EntityFrameworkCore.PostgreSQL&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;6.*&quot; /&gt;&#13;&#10;    &#13;&#10;    &lt;!-- Paquetes de Seguridad --&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.JwtBearer&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authorization&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;System.Drawing.Common&quot; Version=&quot;9.0.10&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;System.IdentityModel.Tokens.Jwt&quot; Version=&quot;7.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;BCrypt.Net-Next&quot; Version=&quot;4.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;ZXing.Net&quot; Version=&quot;0.16.11&quot; /&gt;&#13;&#10;    &lt;!-- Binding para soporte de System.Drawing (BitmapRenderer, BarcodeWriter&lt;Bitmap&gt;) --&gt;&#13;&#10;    &lt;PackageReference Include=&quot;ZXing.Net.Bindings.Windows.Compatibility&quot; Version=&quot;0.16.14&quot; /&gt;&#13;&#10;    &#13;&#10;    &lt;!-- Paquetes de Redis para Caching --&gt;&#13;&#10;    &lt;PackageReference Include=&quot;StackExchange.Redis&quot; Version=&quot;2.8.16&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.Extensions.Caching.StackExchangeRedis&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;  &lt;ItemGroup&gt;&#13;&#10;    &lt;Folder Include=&quot;Application\&quot; /&gt;&#13;&#10;    &lt;Folder Include=&quot;Contacts\&quot; /&gt;&#13;&#10;    &lt;Folder Include=&quot;Domain\&quot; /&gt;&#13;&#10;    &lt;Folder Include=&quot;Endpoints\&quot; /&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;  &lt;!-- Target para limpiar antes del build (solo en Debug) --&gt;&#13;&#10;  &lt;!-- Nota: Este target limpia los archivos de salida antes de compilar --&gt;&#13;&#10;  &lt;Target Name=&quot;PreBuildClean&quot; BeforeTargets=&quot;BeforeBuild&quot; Condition=&quot;'$(Configuration)' == 'Debug'&quot;&gt;&#13;&#10;    &lt;Message Text=&quot;Limpiando archivos de salida antes del build...&quot; Importance=&quot;high&quot; /&gt;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;      &lt;FilesToDelete Include=&quot;$(OutputPath)**\*.*&quot; /&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;    &lt;Delete Files=&quot;@(FilesToDelete)&quot; ContinueOnError=&quot;true&quot; /&gt;&#13;&#10;    &lt;Message Text=&quot;Clean completado. Iniciando build...&quot; Importance=&quot;high&quot; /&gt;&#13;&#10;  &lt;/Target&gt;&#13;&#10;&#13;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/GateKeep.Api/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/GateKeep.Api/Program.cs" />
              <option name="originalContent" value="using System.Text.Json.Serialization;&#10;using GateKeep.Api.Application.Acceso;&#10;using GateKeep.Api.Application.Anuncios;&#10;using GateKeep.Api.Application.Auditoria;&#10;using GateKeep.Api.Application.Beneficios;&#10;using GateKeep.Api.Application.Espacios;&#10;using GateKeep.Api.Application.Eventos;&#10;using GateKeep.Api.Application.Notificaciones;&#10;using GateKeep.Api.Application.Security;&#10;using GateKeep.Api.Application.Usuarios;&#10;using GateKeep.Api.Contracts.Usuarios;&#10;using GateKeep.Api.Domain.Enums;&#10;using GateKeep.Api.Endpoints.Acceso;&#10;using GateKeep.Api.Endpoints.Anuncios;&#10;using GateKeep.Api.Endpoints.Auditoria;&#10;using GateKeep.Api.Endpoints.Auth;&#10;using GateKeep.Api.Endpoints.Beneficios;&#10;using GateKeep.Api.Endpoints.Espacios;&#10;using GateKeep.Api.Endpoints.Eventos;&#10;using GateKeep.Api.Endpoints.Notificaciones;&#10;using GateKeep.Api.Endpoints.Usuarios;&#10;using GateKeep.Api.Endpoints.Shared;&#10;using GateKeep.Api.Infrastructure.Acceso;&#10;using GateKeep.Api.Infrastructure.Anuncios;&#10;using GateKeep.Api.Infrastructure.Auditoria;&#10;using GateKeep.Api.Infrastructure.Beneficios;&#10;using GateKeep.Api.Infrastructure.Caching;&#10;using GateKeep.Api.Infrastructure.Espacios;&#10;using GateKeep.Api.Infrastructure.Eventos;&#10;using GateKeep.Api.Infrastructure.Notificaciones;&#10;using GateKeep.Api.Infrastructure.Persistence;&#10;using GateKeep.Api.Infrastructure.Security;&#10;using GateKeep.Api.Infrastructure.Usuarios;&#10;using GateKeep.Infrastructure.QrCodes;&#10;using Microsoft.EntityFrameworkCore;&#10;using MongoDB.Driver;&#10;using MongoDB.Bson;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.IdentityModel.Tokens;&#10;using System.Text;&#10;using System.Security.Claims;&#10;using Microsoft.OpenApi.Models;&#10;using System.Reflection;&#10;using StackExchange.Redis;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Cargar config.json: hacerlo opcional para entornos Docker donde montamos config.Production.json&#10;builder.Configuration.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);&#10;// Cargar configuración específica para producción si existe&#10;builder.Configuration.AddJsonFile(&quot;config.Production.json&quot;, optional: true, reloadOnChange: true);&#10;// Permitir sobreescritura por variables de entorno&#10;builder.Configuration.AddEnvironmentVariables();&#10;&#10;// Swagger (exploración y documentación)&#10;builder.Services.AddEndpointsApiExplorer();&#10;builder.Services.AddSwaggerGen(c =&gt;&#10;{&#10;    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#10;    { &#10;        Title = &quot;GateKeep API&quot;, &#10;        Version = &quot;v1&quot;,&#10;        Description = &quot;API para el sistema de gestión de acceso GateKeep&quot;,&#10;        Contact = new OpenApiContact&#10;        {&#10;            Name = &quot;GateKeep Team&quot;,&#10;            Email = &quot;support@gatekeep.com&quot;&#10;        }&#10;    });&#10;&#10;    // Configuración para JWT&#10;    c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme&#10;    {&#10;        Description = &quot;JWT Authorization header usando el esquema Bearer. Ejemplo: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;        Name = &quot;Authorization&quot;,&#10;        In = ParameterLocation.Header,&#10;        Type = SecuritySchemeType.Http,&#10;        Scheme = &quot;Bearer&quot;,&#10;        BearerFormat = &quot;JWT&quot;&#10;    });&#10;&#10;    c.AddSecurityRequirement(new OpenApiSecurityRequirement&#10;    {&#10;        {&#10;            new OpenApiSecurityScheme&#10;            {&#10;                Reference = new OpenApiReference&#10;                {&#10;                    Type = ReferenceType.SecurityScheme,&#10;                    Id = &quot;Bearer&quot;&#10;                }&#10;            },&#10;            new string[] {}&#10;        }&#10;    });&#10;&#10;    // Incluir comentarios XML si los tienes&#10;    var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;&#10;    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);&#10;    if (File.Exists(xmlPath))&#10;    {&#10;        c.IncludeXmlComments(xmlPath);&#10;    }&#10;});&#10;&#10;// JSON&#10;builder.Services.ConfigureHttpJsonOptions(o =&gt;&#10;{&#10;    o.SerializerOptions.Converters.Add(new JsonStringEnumConverter());&#10;});&#10;&#10;// Configuración de Seguridad JWT&#10;builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)&#10;    .AddJwtBearer(options =&gt;&#10;    {&#10;        var jwtConfig = builder.Configuration.GetSection(&quot;jwt&quot;);&#10;        var jwtKey = jwtConfig[&quot;key&quot;] ?? throw new InvalidOperationException(&quot;JWT Key no configurada&quot;);&#10;        var jwtIssuer = jwtConfig[&quot;issuer&quot;] ?? &quot;GateKeep&quot;;&#10;        var jwtAudience = jwtConfig[&quot;audience&quot;] ?? &quot;GateKeepUsers&quot;;&#10;        &#10;        options.TokenValidationParameters = new TokenValidationParameters&#10;        {&#10;            ValidateIssuer = true,&#10;            ValidateAudience = true,&#10;            ValidateLifetime = true,&#10;            ValidateIssuerSigningKey = true,&#10;            ValidIssuer = jwtIssuer,&#10;            ValidAudience = jwtAudience,&#10;            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey)),&#10;            ClockSkew = TimeSpan.FromMinutes(5) // Permitir 5 minutos de diferencia&#10;        };&#10;&#10;        // Configuración para Swagger con logging completo&#10;        options.Events = new JwtBearerEvents&#10;        {&#10;            OnAuthenticationFailed = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Authentication Failed: {context.Exception.Message}&quot;);&#10;                Console.WriteLine($&quot;Exception Type: {context.Exception.GetType().Name}&quot;);&#10;                Console.WriteLine($&quot;Request Path: {context.Request.Path}&quot;);&#10;                &#10;                if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))&#10;                {&#10;                    Console.WriteLine(&quot;Token has expired&quot;);&#10;                    context.Response.Headers[&quot;Token-Expired&quot;] = &quot;true&quot;;&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidSignatureException))&#10;                {&#10;                    Console.WriteLine(&quot;Token signature is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidIssuerException))&#10;                {&#10;                    Console.WriteLine(&quot;Token issuer is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidAudienceException))&#10;                {&#10;                    Console.WriteLine(&quot;Token audience is invalid&quot;);&#10;                }&#10;                &#10;                return Task.CompletedTask;&#10;            },&#10;            OnTokenValidated = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Token Validated for user: {context.Principal?.Identity?.Name}&quot;);&#10;                var roles = context.Principal?.FindAll(ClaimTypes.Role).Select(c =&gt; c.Value).ToList() ?? new List&lt;string&gt;();&#10;                Console.WriteLine($&quot;User Roles: {string.Join(&quot;, &quot;, roles)}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnChallenge = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Challenge: {context.Error} - {context.ErrorDescription}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnMessageReceived = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Message Received from: {context.Request.Path}&quot;);&#10;                return Task.CompletedTask;&#10;            }&#10;        };&#10;    });&#10;&#10;// Configuración de Autorización&#10;builder.Services.AddAuthorizationBuilder()&#10;    .AddPolicy(&quot;AdminOnly&quot;, policy =&gt; policy.RequireRole(&quot;Admin&quot;))&#10;    .AddPolicy(&quot;FuncionarioOrAdmin&quot;, policy =&gt; policy.RequireRole(&quot;Funcionario&quot;, &quot;Admin&quot;))&#10;    .AddPolicy(&quot;AllUsers&quot;, policy =&gt; policy.RequireRole(&quot;Estudiante&quot;, &quot;Funcionario&quot;, &quot;Admin&quot;));&#10;&#10;// Configuración de CORS&#10;builder.Services.AddCors(options =&gt;&#10;{&#10;    options.AddPolicy(&quot;AllowFrontend&quot;, policy =&gt;&#10;    {&#10;        policy.WithOrigins(&quot;http://localhost:3000&quot;, &quot;http://127.0.0.1:3000&quot;)&#10;              .AllowAnyMethod()&#10;              .AllowAnyHeader()&#10;              .AllowCredentials();&#10;    });&#10;});&#10;&#10;// EF Core - PostgreSQL&#10;builder.Services.AddDbContext&lt;GateKeepDbContext&gt;(options =&gt;&#10;{&#10;    // Leer configuración desde config.json&#10;    var config = builder.Configuration.GetSection(&quot;database&quot;);&#10;    var host = config[&quot;host&quot;] ?? &quot;localhost&quot;;&#10;    var port = config[&quot;port&quot;] ?? &quot;5432&quot;;&#10;    var database = config[&quot;name&quot;] ?? &quot;GateKeep_Dev&quot;;&#10;    var username = config[&quot;user&quot;] ?? &quot;postgres&quot;;&#10;    var password = config[&quot;password&quot;] ?? &quot;dev_password&quot;;&#10;    &#10;    var connectionString = $&quot;Host={host};Port={port};Database={database};Username={username};Password={password};&quot;;&#10;    &#10;    options.UseNpgsql(connectionString, npgsql =&gt;&#10;    {&#10;        // Usar un esquema interno para el historial de migraciones&#10;        npgsql.MigrationsHistoryTable(&quot;__EFMigrationsHistory&quot;, schema: &quot;infra&quot;);&#10;    });&#10;});&#10;&#10;// Factory Pattern para Espacios&#10;builder.Services.AddScoped&lt;IEspacioRepository, EspacioRepository&gt;();&#10;builder.Services.AddScoped&lt;IEspacioFactory, EspacioFactory&gt;();&#10;&#10;// Servicios de Anuncios&#10;builder.Services.AddScoped&lt;IAnuncioRepository, AnuncioRepository&gt;();&#10;builder.Services.AddScoped&lt;IAnuncioService, AnuncioService&gt;();&#10;&#10;// Servicios de Beneficios&#10;builder.Services.AddScoped&lt;IBeneficioRepository, BeneficioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioService, BeneficioService&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioRepository, BeneficioUsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioService, BeneficioUsuarioService&gt;();&#10;&#10;// Servicios de Eventos&#10;builder.Services.AddScoped&lt;IEventoRepository, EventoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoService, EventoService&gt;();&#10;&#10;// Servicios de Usuarios&#10;builder.Services.AddScoped&lt;IUsuarioRepository, UsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IUsuarioFactory, UsuarioFactory&gt;();&#10;&#10;// Servicios de Acceso&#10;builder.Services.AddScoped&lt;IReglaAccesoRepository, ReglaAccesoRepository&gt;();&#10;builder.Services.AddScoped&lt;IReglaAccesoService, ReglaAccesoService&gt;();&#10;builder.Services.AddScoped&lt;IAccesoService, AccesoService&gt;();&#10;&#10;// Servicios de Seguridad&#10;builder.Services.AddScoped&lt;IPasswordService, PasswordService&gt;();&#10;builder.Services.AddScoped&lt;IAuthService, AuthService&gt;();&#10;&#10;// Utilidades&#10;builder.Services.AddSingleton&lt;QrCodeGenerator&gt;();&#10;&#10;// Servicios de Notificaciones MongoDB&#10;builder.Services.AddScoped&lt;INotificacionRepository, NotificacionRepository&gt;();&#10;builder.Services.AddScoped&lt;INotificacionService, NotificacionService&gt;();&#10;&#10;// Servicios de Auditoria MongoDB&#10;builder.Services.AddScoped&lt;IEventoHistoricoRepository, EventoHistoricoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoHistoricoService, EventoHistoricoService&gt;();&#10;&#10;// MongoDB - Configuración con Atlas y API estable&#10;builder.Services.AddSingleton&lt;IMongoClient&gt;(serviceProvider =&gt;&#10;{&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var connectionString = mongoConfig[&quot;connectionString&quot;] ?? &quot;mongodb://localhost:27017&quot;;&#10;    var useStableApi = mongoConfig.GetValue&lt;bool&gt;(&quot;useStableApi&quot;, false);&#10;    &#10;    try&#10;    {&#10;        if (useStableApi)&#10;        {&#10;            // Configuración para MongoDB Atlas con API estable&#10;            var settings = MongoClientSettings.FromConnectionString(connectionString);&#10;            settings.ServerApi = new ServerApi(ServerApiVersion.V1);&#10;            return new MongoClient(settings);&#10;        }&#10;        else&#10;        {&#10;            // Configuración local simple&#10;            return new MongoClient(connectionString);&#10;        }&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        throw new InvalidOperationException($&quot;Error conectando a MongoDB: {ex.Message}&quot;, ex);&#10;    }&#10;});&#10;&#10;builder.Services.AddScoped&lt;IMongoDatabase&gt;(serviceProvider =&gt;&#10;{&#10;    var client = serviceProvider.GetRequiredService&lt;IMongoClient&gt;();&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var databaseName = mongoConfig[&quot;databaseName&quot;] ?? &quot;GateKeepMongo&quot;;&#10;    &#10;    return client.GetDatabase(databaseName);&#10;});&#10;&#10;// Configuración de Redis&#10;builder.Services.AddStackExchangeRedisCache(options =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    options.Configuration = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    options.InstanceName = redisConfig[&quot;instanceName&quot;] ?? &quot;GateKeepRedis:&quot;;&#10;});&#10;&#10;// Servicios de Redis y Caching&#10;builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(serviceProvider =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    var connectionString = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    return ConnectionMultiplexer.Connect(connectionString);&#10;});&#10;&#10;builder.Services.AddSingleton&lt;ICacheMetricsService, CacheMetricsService&gt;();&#10;builder.Services.AddScoped&lt;ICacheService, RedisCacheService&gt;();&#10;&#10;// Servicios de Beneficios con Caching&#10;builder.Services.AddScoped&lt;ICachedBeneficioService, CachedBeneficioService&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;// Swagger disponible en Development y Production (para demos)&#10;// En un ambiente productivo real, esto debería estar protegido o deshabilitado&#10;app.UseSwagger();&#10;app.UseSwaggerUI(c =&gt;&#10;{&#10;    c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;GateKeep API v1&quot;);&#10;    c.RoutePrefix = &quot;swagger&quot;;&#10;    c.DocumentTitle = &quot;GateKeep API Documentation&quot;;&#10;    c.DefaultModelsExpandDepth(-1); // Ocultar modelos por defecto&#10;    c.DisplayRequestDuration();&#10;    c.EnableDeepLinking();&#10;    // c.EnableFilter(); // ← Comentado para deshabilitar el filtro&#10;    c.ShowExtensions();&#10;    c.EnableValidator();&#10;});&#10;&#10;// Middleware de CORS&#10;app.UseCors(&quot;AllowFrontend&quot;);&#10;&#10;// Middleware de Seguridad&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;&#10;&#10;&#10;// Minimal API&#10;app.MapGet(&quot;/&quot;, () =&gt; Results.Redirect(&quot;/swagger&quot;)).ExcludeFromDescription();&#10;&#10;// Health&#10;app.MapGet(&quot;/health&quot;, () =&gt; Results.Ok(new { status = &quot;ok&quot; }))&#10;  .WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Health Check con ping usando BsonDocument&#10;app.MapGet(&quot;/health/mongodb&quot;, (IMongoClient mongoClient) =&gt;&#10;{&#10;    try&#10;    {&#10;        // Ping usando BsonDocument como en el código de Atlas&#10;        var result = mongoClient.GetDatabase(&quot;admin&quot;).RunCommand&lt;BsonDocument&gt;(new BsonDocument(&quot;ping&quot;, 1));&#10;        return Results.Ok(new { &#10;            status = &quot;ok&quot;, &#10;            database = &quot;MongoDB Atlas&quot;, &#10;            message = &quot;Pinged your deployment. You successfully connected to MongoDB!&quot;,&#10;            pingResult = result.ToString()&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a MongoDB Atlas: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// Redis Health Check&#10;app.MapGet(&quot;/health/redis&quot;, (IConnectionMultiplexer redis) =&gt;&#10;{&#10;    try&#10;    {&#10;        var isConnected = redis.IsConnected;&#10;        &#10;        return Results.Ok(new&#10;        {&#10;            status = isConnected ? &quot;ok&quot; : &quot;disconnected&quot;,&#10;            isConnected,&#10;            endpoints = redis.GetEndPoints().Select(ep =&gt; ep.ToString()).ToArray(),&#10;            message = &quot;Redis is connected and operational&quot;&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a Redis: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Clear Database - Eliminar todos los datos (Solo en desarrollo)&#10;app.MapDelete(&quot;/system/mongodb/clear&quot;, (IMongoDatabase mongoDatabase, IWebHostEnvironment env) =&gt;&#10;{&#10;    // Validación de seguridad - Solo permitir en desarrollo&#10;    if (!env.IsDevelopment())&#10;    {&#10;        return Results.Problem(&#10;            &quot;Este endpoint solo está disponible en modo desarrollo&quot;,&#10;            statusCode: 403&#10;        );&#10;    }&#10;&#10;    try&#10;    {&#10;        // Obtener lista de todas las colecciones&#10;        var collections = mongoDatabase.ListCollectionNames().ToList();&#10;        var deletedCollections = new List&lt;string&gt;();&#10;        var totalDocumentsDeleted = 0;&#10;&#10;        foreach (var collectionName in collections)&#10;        {&#10;            var collection = mongoDatabase.GetCollection&lt;BsonDocument&gt;(collectionName);&#10;            var count = collection.CountDocuments(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            &#10;            // Eliminar todos los documentos de la colección&#10;            var deleteResult = collection.DeleteMany(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            totalDocumentsDeleted += (int)deleteResult.DeletedCount;&#10;            deletedCollections.Add(collectionName);&#10;        }&#10;&#10;        return Results.Ok(new&#10;        {&#10;            status = &quot;success&quot;,&#10;            message = &quot;Base de datos MongoDB limpiada exitosamente&quot;,&#10;            environment = &quot;Development&quot;,&#10;            deletedCollections = deletedCollections,&#10;            totalDocumentsDeleted = totalDocumentsDeleted,&#10;            timestamp = DateTime.UtcNow&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error limpiando la base de datos MongoDB: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;)&#10;.WithSummary(&quot;Limpiar todos los datos de MongoDB&quot;)&#10;.WithDescription(&quot;Elimina todos los documentos de todas las colecciones en la base de datos MongoDB&quot;);&#10;&#10;// Endpoints&#10;app.MapAccesoEndpoints();&#10;app.MapAnuncioEndpoints();&#10;app.MapAuthEndpoints();&#10;app.MapEdificioEndpoints();&#10;app.MapEventoEndpoints();&#10;app.MapEventoHistoricoEndpoints();&#10;app.MapLaboratorioEndpoints();&#10;app.MapReglaAccesoEndpoints();&#10;app.MapSalonEndpoints();&#10;app.MapBeneficioEndpoints();&#10;app.MapNotificacionEndpoints();&#10;app.MapUsuarioEndpoints();&#10;app.MapUsuarioProfileEndpoints();&#10;app.MapCacheMetricsEndpoints(); // Endpoint de métricas de cache&#10;&#10;// Auto-aplicar migraciones al iniciar&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var db = scope.ServiceProvider.GetRequiredService&lt;GateKeepDbContext&gt;();&#10;    &#10;    if (app.Environment.IsDevelopment())&#10;    {&#10;        // En desarrollo: recrear BD automáticamente&#10;        db.Database.EnsureDeleted();&#10;        db.Database.EnsureCreated();&#10;        &#10;        // Seed data inicial&#10;        if (!db.Usuarios.Any())&#10;        {&#10;            var factory = scope.ServiceProvider.GetRequiredService&lt;IUsuarioFactory&gt;();&#10;            var passwordService = scope.ServiceProvider.GetRequiredService&lt;IPasswordService&gt;();&#10;            &#10;            // Crear usuario admin por defecto&#10;            var adminDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;admin@gatekeep.com&quot;,&#10;                Nombre = &quot;Administrador&quot;,&#10;                Apellido = &quot;Sistema&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;admin123&quot;),&#10;                Telefono = &quot;+1234567890&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Admin&#10;            };&#10;            &#10;            var admin = factory.CrearUsuario(adminDto);&#10;            db.Usuarios.Add(admin);&#10;            &#10;            // Crear estudiante de ejemplo&#10;            var estudianteDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;estudiante@gatekeep.com&quot;,&#10;                Nombre = &quot;Juan&quot;,&#10;                Apellido = &quot;Pérez&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;estudiante123&quot;),&#10;                Telefono = &quot;+1234567891&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Estudiante&#10;            };&#10;            &#10;            var estudiante = factory.CrearUsuario(estudianteDto);&#10;            db.Usuarios.Add(estudiante);&#10;            &#10;            // Crear funcionario de ejemplo&#10;            var funcionarioDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;funcionario@gatekeep.com&quot;,&#10;                Nombre = &quot;María&quot;,&#10;                Apellido = &quot;García&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;funcionario123&quot;),&#10;                Telefono = &quot;+1234567892&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Funcionario&#10;            };&#10;            &#10;            var funcionario = factory.CrearUsuario(funcionarioDto);&#10;            db.Usuarios.Add(funcionario);&#10;            &#10;            await db.SaveChangesAsync();&#10;        }&#10;    }&#10;    else&#10;    {&#10;        // En producción: solo migraciones&#10;        db.Database.Migrate();&#10;    }&#10;}&#10;&#10;&#10;app.Run();&#10;" />
              <option name="updatedContent" value="using System.Text.Json.Serialization;&#10;using GateKeep.Api.Application.Acceso;&#10;using GateKeep.Api.Application.Anuncios;&#10;using GateKeep.Api.Application.Auditoria;&#10;using GateKeep.Api.Application.Beneficios;&#10;using GateKeep.Api.Application.Espacios;&#10;using GateKeep.Api.Application.Eventos;&#10;using GateKeep.Api.Application.Notificaciones;&#10;using GateKeep.Api.Application.Security;&#10;using GateKeep.Api.Application.Usuarios;&#10;using GateKeep.Api.Contracts.Usuarios;&#10;using GateKeep.Api.Domain.Enums;&#10;using GateKeep.Api.Endpoints.Acceso;&#10;using GateKeep.Api.Endpoints.Anuncios;&#10;using GateKeep.Api.Endpoints.Auditoria;&#10;using GateKeep.Api.Endpoints.Auth;&#10;using GateKeep.Api.Endpoints.Beneficios;&#10;using GateKeep.Api.Endpoints.Espacios;&#10;using GateKeep.Api.Endpoints.Eventos;&#10;using GateKeep.Api.Endpoints.Notificaciones;&#10;using GateKeep.Api.Endpoints.Usuarios;&#10;using GateKeep.Api.Endpoints.Shared;&#10;using GateKeep.Api.Infrastructure.Acceso;&#10;using GateKeep.Api.Infrastructure.Anuncios;&#10;using GateKeep.Api.Infrastructure.Auditoria;&#10;using GateKeep.Api.Infrastructure.Beneficios;&#10;using GateKeep.Api.Infrastructure.Caching;&#10;using GateKeep.Api.Infrastructure.Espacios;&#10;using GateKeep.Api.Infrastructure.Eventos;&#10;using GateKeep.Api.Infrastructure.Notificaciones;&#10;using GateKeep.Api.Infrastructure.Persistence;&#10;using GateKeep.Api.Infrastructure.Security;&#10;using GateKeep.Api.Infrastructure.Usuarios;&#10;using GateKeep.Infrastructure.QrCodes;&#10;using Microsoft.EntityFrameworkCore;&#10;using MongoDB.Driver;&#10;using MongoDB.Bson;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.IdentityModel.Tokens;&#10;using System.Text;&#10;using System.Security.Claims;&#10;using Microsoft.OpenApi.Models;&#10;using System.Reflection;&#10;using StackExchange.Redis;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Cargar config.json: hacerlo opcional para entornos Docker donde montamos config.Production.json&#10;builder.Configuration.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);&#10;// Cargar configuración específica para producción si existe&#10;builder.Configuration.AddJsonFile(&quot;config.Production.json&quot;, optional: true, reloadOnChange: true);&#10;// Permitir sobreescritura por variables de entorno&#10;builder.Configuration.AddEnvironmentVariables();&#10;&#10;// Swagger (exploración y documentación)&#10;builder.Services.AddEndpointsApiExplorer();&#10;builder.Services.AddSwaggerGen(c =&gt;&#10;{&#10;    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#10;    { &#10;        Title = &quot;GateKeep API&quot;, &#10;        Version = &quot;v1&quot;,&#10;        Description = &quot;API para el sistema de gestión de acceso GateKeep&quot;,&#10;        Contact = new OpenApiContact&#10;        {&#10;            Name = &quot;GateKeep Team&quot;,&#10;            Email = &quot;support@gatekeep.com&quot;&#10;        }&#10;    });&#10;&#10;    // Configuración para JWT&#10;    c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme&#10;    {&#10;        Description = &quot;JWT Authorization header usando el esquema Bearer. Ejemplo: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;        Name = &quot;Authorization&quot;,&#10;        In = ParameterLocation.Header,&#10;        Type = SecuritySchemeType.Http,&#10;        Scheme = &quot;Bearer&quot;,&#10;        BearerFormat = &quot;JWT&quot;&#10;    });&#10;&#10;    c.AddSecurityRequirement(new OpenApiSecurityRequirement&#10;    {&#10;        {&#10;            new OpenApiSecurityScheme&#10;            {&#10;                Reference = new OpenApiReference&#10;                {&#10;                    Type = ReferenceType.SecurityScheme,&#10;                    Id = &quot;Bearer&quot;&#10;                }&#10;            },&#10;            new string[] {}&#10;        }&#10;    });&#10;&#10;    // Incluir comentarios XML si los tienes&#10;    var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;&#10;    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);&#10;    if (File.Exists(xmlPath))&#10;    {&#10;        c.IncludeXmlComments(xmlPath);&#10;    }&#10;});&#10;&#10;// JSON&#10;builder.Services.ConfigureHttpJsonOptions(o =&gt;&#10;{&#10;    o.SerializerOptions.Converters.Add(new JsonStringEnumConverter());&#10;});&#10;&#10;// Configuración de Seguridad JWT&#10;builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)&#10;    .AddJwtBearer(options =&gt;&#10;    {&#10;        var jwtConfig = builder.Configuration.GetSection(&quot;jwt&quot;);&#10;        var jwtKey = jwtConfig[&quot;key&quot;] ?? throw new InvalidOperationException(&quot;JWT Key no configurada&quot;);&#10;        var jwtIssuer = jwtConfig[&quot;issuer&quot;] ?? &quot;GateKeep&quot;;&#10;        var jwtAudience = jwtConfig[&quot;audience&quot;] ?? &quot;GateKeepUsers&quot;;&#10;        &#10;        options.TokenValidationParameters = new TokenValidationParameters&#10;        {&#10;            ValidateIssuer = true,&#10;            ValidateAudience = true,&#10;            ValidateLifetime = true,&#10;            ValidateIssuerSigningKey = true,&#10;            ValidIssuer = jwtIssuer,&#10;            ValidAudience = jwtAudience,&#10;            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey)),&#10;            ClockSkew = TimeSpan.FromMinutes(5) // Permitir 5 minutos de diferencia&#10;        };&#10;&#10;        // Configuración para Swagger con logging completo&#10;        options.Events = new JwtBearerEvents&#10;        {&#10;            OnAuthenticationFailed = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Authentication Failed: {context.Exception.Message}&quot;);&#10;                Console.WriteLine($&quot;Exception Type: {context.Exception.GetType().Name}&quot;);&#10;                Console.WriteLine($&quot;Request Path: {context.Request.Path}&quot;);&#10;                &#10;                if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))&#10;                {&#10;                    Console.WriteLine(&quot;Token has expired&quot;);&#10;                    context.Response.Headers[&quot;Token-Expired&quot;] = &quot;true&quot;;&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidSignatureException))&#10;                {&#10;                    Console.WriteLine(&quot;Token signature is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidIssuerException))&#10;                {&#10;                    Console.WriteLine(&quot;Token issuer is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidAudienceException))&#10;                {&#10;                    Console.WriteLine(&quot;Token audience is invalid&quot;);&#10;                }&#10;                &#10;                return Task.CompletedTask;&#10;            },&#10;            OnTokenValidated = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Token Validated for user: {context.Principal?.Identity?.Name}&quot;);&#10;                var roles = context.Principal?.FindAll(ClaimTypes.Role).Select(c =&gt; c.Value).ToList() ?? new List&lt;string&gt;();&#10;                Console.WriteLine($&quot;User Roles: {string.Join(&quot;, &quot;, roles)}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnChallenge = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Challenge: {context.Error} - {context.ErrorDescription}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnMessageReceived = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Message Received from: {context.Request.Path}&quot;);&#10;                return Task.CompletedTask;&#10;            }&#10;        };&#10;    });&#10;&#10;// Configuración de Autorización&#10;builder.Services.AddAuthorizationBuilder()&#10;    .AddPolicy(&quot;AdminOnly&quot;, policy =&gt; policy.RequireRole(&quot;Admin&quot;))&#10;    .AddPolicy(&quot;FuncionarioOrAdmin&quot;, policy =&gt; policy.RequireRole(&quot;Funcionario&quot;, &quot;Admin&quot;))&#10;    .AddPolicy(&quot;AllUsers&quot;, policy =&gt; policy.RequireRole(&quot;Estudiante&quot;, &quot;Funcionario&quot;, &quot;Admin&quot;));&#10;&#10;// Configuración de CORS&#10;builder.Services.AddCors(options =&gt;&#10;{&#10;    options.AddPolicy(&quot;AllowFrontend&quot;, policy =&gt;&#10;    {&#10;        policy.WithOrigins(&quot;http://localhost:3000&quot;, &quot;http://127.0.0.1:3000&quot;)&#10;              .AllowAnyMethod()&#10;              .AllowAnyHeader()&#10;              .AllowCredentials();&#10;    });&#10;});&#10;&#10;// EF Core - PostgreSQL&#10;builder.Services.AddDbContext&lt;GateKeepDbContext&gt;(options =&gt;&#10;{&#10;    // Leer configuración desde config.json&#10;    var config = builder.Configuration.GetSection(&quot;database&quot;);&#10;    var host = config[&quot;host&quot;] ?? &quot;localhost&quot;;&#10;    var port = config[&quot;port&quot;] ?? &quot;5432&quot;;&#10;    var database = config[&quot;name&quot;] ?? &quot;GateKeep_Dev&quot;;&#10;    var username = config[&quot;user&quot;] ?? &quot;postgres&quot;;&#10;    var password = config[&quot;password&quot;] ?? &quot;dev_password&quot;;&#10;    &#10;    var connectionString = $&quot;Host={host};Port={port};Database={database};Username={username};Password={password};&quot;;&#10;    &#10;    options.UseNpgsql(connectionString, npgsql =&gt;&#10;    {&#10;        // Usar un esquema interno para el historial de migraciones&#10;        npgsql.MigrationsHistoryTable(&quot;__EFMigrationsHistory&quot;, schema: &quot;infra&quot;);&#10;    });&#10;});&#10;&#10;// Factory Pattern para Espacios&#10;builder.Services.AddScoped&lt;IEspacioRepository, EspacioRepository&gt;();&#10;builder.Services.AddScoped&lt;IEspacioFactory, EspacioFactory&gt;();&#10;&#10;// Servicios de Anuncios&#10;builder.Services.AddScoped&lt;IAnuncioRepository, AnuncioRepository&gt;();&#10;builder.Services.AddScoped&lt;IAnuncioService, AnuncioService&gt;();&#10;&#10;// Servicios de Beneficios&#10;builder.Services.AddScoped&lt;IBeneficioRepository, BeneficioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioService, BeneficioService&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioRepository, BeneficioUsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioService, BeneficioUsuarioService&gt;();&#10;&#10;// Servicios de Eventos&#10;builder.Services.AddScoped&lt;IEventoRepository, EventoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoService, EventoService&gt;();&#10;&#10;// Servicios de Usuarios&#10;builder.Services.AddScoped&lt;IUsuarioRepository, UsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IUsuarioFactory, UsuarioFactory&gt;();&#10;&#10;// Servicios de Acceso&#10;builder.Services.AddScoped&lt;IReglaAccesoRepository, ReglaAccesoRepository&gt;();&#10;builder.Services.AddScoped&lt;IReglaAccesoService, ReglaAccesoService&gt;();&#10;builder.Services.AddScoped&lt;IAccesoService, AccesoService&gt;();&#10;&#10;// Servicios de Seguridad&#10;builder.Services.AddScoped&lt;IPasswordService, PasswordService&gt;();&#10;builder.Services.AddScoped&lt;IAuthService, AuthService&gt;();&#10;&#10;// Utilidades&#10;builder.Services.AddSingleton&lt;QrCodeGenerator&gt;();&#10;&#10;// Servicios de Notificaciones MongoDB&#10;builder.Services.AddScoped&lt;INotificacionRepository, NotificacionRepository&gt;();&#10;builder.Services.AddScoped&lt;INotificacionService, NotificacionService&gt;();&#10;&#10;// Servicios de Auditoria MongoDB&#10;builder.Services.AddScoped&lt;IEventoHistoricoRepository, EventoHistoricoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoHistoricoService, EventoHistoricoService&gt;();&#10;&#10;// MongoDB - Configuración con Atlas y API estable&#10;builder.Services.AddSingleton&lt;IMongoClient&gt;(serviceProvider =&gt;&#10;{&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var connectionString = mongoConfig[&quot;connectionString&quot;] ?? &quot;mongodb://localhost:27017&quot;;&#10;    var useStableApi = mongoConfig.GetValue&lt;bool&gt;(&quot;useStableApi&quot;, false);&#10;    &#10;    try&#10;    {&#10;        if (useStableApi)&#10;        {&#10;            // Configuración para MongoDB Atlas con API estable&#10;            var settings = MongoClientSettings.FromConnectionString(connectionString);&#10;            settings.ServerApi = new ServerApi(ServerApiVersion.V1);&#10;            return new MongoClient(settings);&#10;        }&#10;        else&#10;        {&#10;            // Configuración local simple&#10;            return new MongoClient(connectionString);&#10;        }&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        throw new InvalidOperationException($&quot;Error conectando a MongoDB: {ex.Message}&quot;, ex);&#10;    }&#10;});&#10;&#10;builder.Services.AddScoped&lt;IMongoDatabase&gt;(serviceProvider =&gt;&#10;{&#10;    var client = serviceProvider.GetRequiredService&lt;IMongoClient&gt;();&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var databaseName = mongoConfig[&quot;databaseName&quot;] ?? &quot;GateKeepMongo&quot;;&#10;    &#10;    return client.GetDatabase(databaseName);&#10;});&#10;&#10;// Configuración de Redis&#10;builder.Services.AddStackExchangeRedisCache(options =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    options.Configuration = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    options.InstanceName = redisConfig[&quot;instanceName&quot;] ?? &quot;GateKeepRedis:&quot;;&#10;});&#10;&#10;// Servicios de Redis y Caching&#10;builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(serviceProvider =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    var connectionString = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    return ConnectionMultiplexer.Connect(connectionString);&#10;});&#10;&#10;builder.Services.AddSingleton&lt;ICacheMetricsService, CacheMetricsService&gt;();&#10;builder.Services.AddScoped&lt;ICacheService, RedisCacheService&gt;();&#10;&#10;// Servicios de Beneficios con Caching&#10;builder.Services.AddScoped&lt;ICachedBeneficioService, CachedBeneficioService&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;// Aplicar migraciones automáticamente al iniciar (para Docker/Production)&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var services = scope.ServiceProvider;&#10;    try&#10;    {&#10;        var context = services.GetRequiredService&lt;GateKeepDbContext&gt;();&#10;        var logger = services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();&#10;        &#10;        logger.LogInformation(&quot;Aplicando migraciones de base de datos...&quot;);&#10;        context.Database.Migrate();&#10;        logger.LogInformation(&quot;Migraciones aplicadas exitosamente&quot;);&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        var logger = services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();&#10;        logger.LogError(ex, &quot;Error al aplicar migraciones de base de datos&quot;);&#10;        throw;&#10;    }&#10;}&#10;&#10;// Swagger disponible en Development y Production (para demos)&#10;// En un ambiente productivo real, esto debería estar protegido o deshabilitado&#10;app.UseSwagger();&#10;app.UseSwaggerUI(c =&gt;&#10;{&#10;    c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;GateKeep API v1&quot;);&#10;    c.RoutePrefix = &quot;swagger&quot;;&#10;    c.DocumentTitle = &quot;GateKeep API Documentation&quot;;&#10;    c.DefaultModelsExpandDepth(-1); // Ocultar modelos por defecto&#10;    c.DisplayRequestDuration();&#10;    c.EnableDeepLinking();&#10;    // c.EnableFilter(); // ← Comentado para deshabilitar el filtro&#10;    c.ShowExtensions();&#10;    c.EnableValidator();&#10;});&#10;&#10;// Middleware de CORS&#10;app.UseCors(&quot;AllowFrontend&quot;);&#10;&#10;// Middleware de Seguridad&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;&#10;&#10;&#10;// Minimal API&#10;app.MapGet(&quot;/&quot;, () =&gt; Results.Redirect(&quot;/swagger&quot;)).ExcludeFromDescription();&#10;&#10;// Health&#10;app.MapGet(&quot;/health&quot;, () =&gt; Results.Ok(new { status = &quot;ok&quot; }))&#10;  .WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Health Check con ping usando BsonDocument&#10;app.MapGet(&quot;/health/mongodb&quot;, (IMongoClient mongoClient) =&gt;&#10;{&#10;    try&#10;    {&#10;        // Ping usando BsonDocument como en el código de Atlas&#10;        var result = mongoClient.GetDatabase(&quot;admin&quot;).RunCommand&lt;BsonDocument&gt;(new BsonDocument(&quot;ping&quot;, 1));&#10;        return Results.Ok(new { &#10;            status = &quot;ok&quot;, &#10;            database = &quot;MongoDB Atlas&quot;, &#10;            message = &quot;Pinged your deployment. You successfully connected to MongoDB!&quot;,&#10;            pingResult = result.ToString()&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a MongoDB Atlas: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// Redis Health Check&#10;app.MapGet(&quot;/health/redis&quot;, (IConnectionMultiplexer redis) =&gt;&#10;{&#10;    try&#10;    {&#10;        var isConnected = redis.IsConnected;&#10;        &#10;        return Results.Ok(new&#10;        {&#10;            status = isConnected ? &quot;ok&quot; : &quot;disconnected&quot;,&#10;            isConnected,&#10;            endpoints = redis.GetEndPoints().Select(ep =&gt; ep.ToString()).ToArray(),&#10;            message = &quot;Redis is connected and operational&quot;&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a Redis: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Clear Database - Eliminar todos los datos (Solo en desarrollo)&#10;app.MapDelete(&quot;/system/mongodb/clear&quot;, (IMongoDatabase mongoDatabase, IWebHostEnvironment env) =&gt;&#10;{&#10;    // Validación de seguridad - Solo permitir en desarrollo&#10;    if (!env.IsDevelopment())&#10;    {&#10;        return Results.Problem(&#10;            &quot;Este endpoint solo está disponible en modo desarrollo&quot;,&#10;            statusCode: 403&#10;        );&#10;    }&#10;&#10;    try&#10;    {&#10;        // Obtener lista de todas las colecciones&#10;        var collections = mongoDatabase.ListCollectionNames().ToList();&#10;        var deletedCollections = new List&lt;string&gt;();&#10;        var totalDocumentsDeleted = 0;&#10;&#10;        foreach (var collectionName in collections)&#10;        {&#10;            var collection = mongoDatabase.GetCollection&lt;BsonDocument&gt;(collectionName);&#10;            var count = collection.CountDocuments(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            &#10;            // Eliminar todos los documentos de la colección&#10;            var deleteResult = collection.DeleteMany(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            totalDocumentsDeleted += (int)deleteResult.DeletedCount;&#10;            deletedCollections.Add(collectionName);&#10;        }&#10;&#10;        return Results.Ok(new&#10;        {&#10;            status = &quot;success&quot;,&#10;            message = &quot;Base de datos MongoDB limpiada exitosamente&quot;,&#10;            environment = &quot;Development&quot;,&#10;            deletedCollections = deletedCollections,&#10;            totalDocumentsDeleted = totalDocumentsDeleted,&#10;            timestamp = DateTime.UtcNow&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error limpiando la base de datos MongoDB: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;)&#10;.WithSummary(&quot;Limpiar todos los datos de MongoDB&quot;)&#10;.WithDescription(&quot;Elimina todos los documentos de todas las colecciones en la base de datos MongoDB&quot;);&#10;&#10;// Endpoints&#10;app.MapAccesoEndpoints();&#10;app.MapAnuncioEndpoints();&#10;app.MapAuthEndpoints();&#10;app.MapEdificioEndpoints();&#10;app.MapEventoEndpoints();&#10;app.MapEventoHistoricoEndpoints();&#10;app.MapLaboratorioEndpoints();&#10;app.MapReglaAccesoEndpoints();&#10;app.MapSalonEndpoints();&#10;app.MapBeneficioEndpoints();&#10;app.MapNotificacionEndpoints();&#10;app.MapUsuarioEndpoints();&#10;app.MapUsuarioProfileEndpoints();&#10;app.MapCacheMetricsEndpoints(); // Endpoint de métricas de cache&#10;&#10;// Auto-aplicar migraciones al iniciar&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var db = scope.ServiceProvider.GetRequiredService&lt;GateKeepDbContext&gt;();&#10;    &#10;    if (app.Environment.IsDevelopment())&#10;    {&#10;        // En desarrollo: recrear BD automáticamente&#10;        db.Database.EnsureDeleted();&#10;        db.Database.EnsureCreated();&#10;        &#10;        // Seed data inicial&#10;        if (!db.Usuarios.Any())&#10;        {&#10;            var factory = scope.ServiceProvider.GetRequiredService&lt;IUsuarioFactory&gt;();&#10;            var passwordService = scope.ServiceProvider.GetRequiredService&lt;IPasswordService&gt;();&#10;            &#10;            // Crear usuario admin por defecto&#10;            var adminDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;admin@gatekeep.com&quot;,&#10;                Nombre = &quot;Administrador&quot;,&#10;                Apellido = &quot;Sistema&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;admin123&quot;),&#10;                Telefono = &quot;+1234567890&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Admin&#10;            };&#10;            &#10;            var admin = factory.CrearUsuario(adminDto);&#10;            db.Usuarios.Add(admin);&#10;            &#10;            // Crear estudiante de ejemplo&#10;            var estudianteDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;estudiante@gatekeep.com&quot;,&#10;                Nombre = &quot;Juan&quot;,&#10;                Apellido = &quot;Pérez&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;estudiante123&quot;),&#10;                Telefono = &quot;+1234567891&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Estudiante&#10;            };&#10;            &#10;            var estudiante = factory.CrearUsuario(estudianteDto);&#10;            db.Usuarios.Add(estudiante);&#10;            &#10;            // Crear funcionario de ejemplo&#10;            var funcionarioDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;funcionario@gatekeep.com&quot;,&#10;                Nombre = &quot;María&quot;,&#10;                Apellido = &quot;García&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;funcionario123&quot;),&#10;                Telefono = &quot;+1234567892&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Funcionario&#10;            };&#10;            &#10;            var funcionario = factory.CrearUsuario(funcionarioDto);&#10;            db.Usuarios.Add(funcionario);&#10;            &#10;            await db.SaveChangesAsync();&#10;        }&#10;    }&#10;    else&#10;    {&#10;        // En producción: solo migraciones&#10;        db.Database.Migrate();&#10;    }&#10;}&#10;&#10;&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/docker-entrypoint.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/docker-entrypoint.sh" />
              <option name="originalContent" value="#!/bin/sh&#10;set -e&#10;&#10;echo &quot;Waiting for PostgreSQL to be ready...&quot;&#10;&#10;# Extraer host y puerto de las variables de entorno&#10;DB_HOST=&quot;${DATABASE__HOST:-db}&quot;&#10;DB_PORT=&quot;${DATABASE__PORT:-5432}&quot;&#10;&#10;# Esperar hasta que PostgreSQL esté disponible&#10;until nc -z &quot;$DB_HOST&quot; &quot;$DB_PORT&quot;; do&#10;  echo &quot;PostgreSQL is unavailable - sleeping&quot;&#10;  sleep 2&#10;done&#10;&#10;echo &quot;PostgreSQL is up - starting application&quot;&#10;&#10;# Ejecutar el comando original&#10;exec &quot;$@&quot;&#10;&#10;" />
              <option name="updatedContent" value="#!/bin/sh&#10;set -e&#10;&#10;echo &quot;Waiting for PostgreSQL to be ready...&quot;&#10;&#10;# Extraer host y puerto de las variables de entorno&#10;DB_HOST=&quot;${DATABASE__HOST:-db}&quot;&#10;DB_PORT=&quot;${DATABASE__PORT:-5432}&quot;&#10;&#10;# Esperar hasta que PostgreSQL esté disponible&#10;until nc -z &quot;$DB_HOST&quot; &quot;$DB_PORT&quot;; do&#10;  echo &quot;PostgreSQL is unavailable - sleeping&quot;&#10;  sleep 2&#10;done&#10;&#10;echo &quot;PostgreSQL is up - starting application&quot;&#10;&#10;# Ejecutar el comando original&#10;exec &quot;$@&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>