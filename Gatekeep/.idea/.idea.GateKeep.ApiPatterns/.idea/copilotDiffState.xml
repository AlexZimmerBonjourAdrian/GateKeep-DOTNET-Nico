<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/GateKeep.Api/GateKeep.Api.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/GateKeep.Api/GateKeep.Api.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;&#10;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;    &lt;RootNamespace&gt;GateKeep.Api&lt;/RootNamespace&gt;&#10;  &lt;/PropertyGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;MassTransit&quot; Version=&quot;8.2.5&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;MassTransit.RabbitMQ&quot; Version=&quot;8.2.5&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.OpenApi&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.Design&quot; Version=&quot;8.*&quot;&gt;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;    &lt;/PackageReference&gt;&#10;    &lt;PackageReference Include=&quot;MongoDB.Driver&quot; Version=&quot;3.5.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Npgsql.EntityFrameworkCore.PostgreSQL&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;6.*&quot; /&gt;&#10;    &#10;    &lt;!-- Paquetes de Seguridad --&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.JwtBearer&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authorization&quot; Version=&quot;8.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;System.Drawing.Common&quot; Version=&quot;9.0.10&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;System.IdentityModel.Tokens.Jwt&quot; Version=&quot;7.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;BCrypt.Net-Next&quot; Version=&quot;4.*&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;ZXing.Net&quot; Version=&quot;0.16.11&quot; /&gt;&#10;    &lt;!-- Binding para soporte de System.Drawing (BitmapRenderer, BarcodeWriter&lt;Bitmap&gt;) --&gt;&#10;    &lt;PackageReference Include=&quot;ZXing.Net.Bindings.Windows.Compatibility&quot; Version=&quot;0.16.14&quot; /&gt;&#10;    &#10;    &lt;!-- Paquetes de Redis para Caching --&gt;&#10;    &lt;PackageReference Include=&quot;StackExchange.Redis&quot; Version=&quot;2.8.16&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.Extensions.Caching.StackExchangeRedis&quot; Version=&quot;8.*&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;ItemGroup&gt;&#10;    &lt;Folder Include=&quot;Application\&quot; /&gt;&#10;    &lt;Folder Include=&quot;Contacts\&quot; /&gt;&#10;    &lt;Folder Include=&quot;Domain\&quot; /&gt;&#10;    &lt;Folder Include=&quot;Endpoints\&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&#10;  &lt;!-- Target para limpiar antes del build (solo en Debug) --&gt;&#10;  &lt;!-- Nota: Este target limpia los archivos de salida antes de compilar --&gt;&#10;  &lt;Target Name=&quot;PreBuildClean&quot; BeforeTargets=&quot;BeforeBuild&quot; Condition=&quot;'$(Configuration)' == 'Debug'&quot;&gt;&#10;    &lt;Message Text=&quot;Limpiando archivos de salida antes del build...&quot; Importance=&quot;high&quot; /&gt;&#10;    &lt;ItemGroup&gt;&#10;      &lt;FilesToDelete Include=&quot;$(OutputPath)**\*.*&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;    &lt;Delete Files=&quot;@(FilesToDelete)&quot; ContinueOnError=&quot;true&quot; /&gt;&#10;    &lt;Message Text=&quot;Clean completado. Iniciando build...&quot; Importance=&quot;high&quot; /&gt;&#10;  &lt;/Target&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt;&#13;&#10;&#13;&#10;  &lt;PropertyGroup&gt;&#13;&#10;    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#13;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#13;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#13;&#10;    &lt;RootNamespace&gt;GateKeep.Api&lt;/RootNamespace&gt;&#13;&#10;  &lt;/PropertyGroup&gt;&#13;&#10;&#13;&#10;  &lt;ItemGroup&gt;&#13;&#10;    &lt;PackageReference Include=&quot;MassTransit&quot; Version=&quot;8.2.5&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;MassTransit.RabbitMQ&quot; Version=&quot;8.2.5&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.OpenApi&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.Design&quot; Version=&quot;8.*&quot;&gt;&#13;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#13;&#10;      &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#13;&#10;    &lt;/PackageReference&gt;&#13;&#10;    &lt;PackageReference Include=&quot;MongoDB.Driver&quot; Version=&quot;3.5.0&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Npgsql.EntityFrameworkCore.PostgreSQL&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Swashbuckle.AspNetCore&quot; Version=&quot;6.*&quot; /&gt;&#13;&#10;    &#13;&#10;    &lt;!-- Paquetes de Seguridad --&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.JwtBearer&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authorization&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;System.Drawing.Common&quot; Version=&quot;9.0.10&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;System.IdentityModel.Tokens.Jwt&quot; Version=&quot;7.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;BCrypt.Net-Next&quot; Version=&quot;4.*&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;ZXing.Net&quot; Version=&quot;0.16.11&quot; /&gt;&#13;&#10;    &lt;!-- Binding para soporte de System.Drawing (BitmapRenderer, BarcodeWriter&lt;Bitmap&gt;) --&gt;&#13;&#10;    &lt;PackageReference Include=&quot;ZXing.Net.Bindings.Windows.Compatibility&quot; Version=&quot;0.16.14&quot; /&gt;&#13;&#10;    &#13;&#10;    &lt;!-- Paquetes de Redis para Caching --&gt;&#13;&#10;    &lt;PackageReference Include=&quot;StackExchange.Redis&quot; Version=&quot;2.8.16&quot; /&gt;&#13;&#10;    &lt;PackageReference Include=&quot;Microsoft.Extensions.Caching.StackExchangeRedis&quot; Version=&quot;8.*&quot; /&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;  &lt;ItemGroup&gt;&#13;&#10;    &lt;Folder Include=&quot;Application\&quot; /&gt;&#13;&#10;    &lt;Folder Include=&quot;Contacts\&quot; /&gt;&#13;&#10;    &lt;Folder Include=&quot;Domain\&quot; /&gt;&#13;&#10;    &lt;Folder Include=&quot;Endpoints\&quot; /&gt;&#13;&#10;  &lt;/ItemGroup&gt;&#13;&#10;&#13;&#10;  &lt;!-- Target para limpiar antes del build (solo en Debug) --&gt;&#13;&#10;  &lt;!-- Nota: Este target limpia los archivos de salida antes de compilar --&gt;&#13;&#10;  &lt;Target Name=&quot;PreBuildClean&quot; BeforeTargets=&quot;BeforeBuild&quot; Condition=&quot;'$(Configuration)' == 'Debug'&quot;&gt;&#13;&#10;    &lt;Message Text=&quot;Limpiando archivos de salida antes del build...&quot; Importance=&quot;high&quot; /&gt;&#13;&#10;    &lt;ItemGroup&gt;&#13;&#10;      &lt;FilesToDelete Include=&quot;$(OutputPath)**\*.*&quot; /&gt;&#13;&#10;    &lt;/ItemGroup&gt;&#13;&#10;    &lt;Delete Files=&quot;@(FilesToDelete)&quot; ContinueOnError=&quot;true&quot; /&gt;&#13;&#10;    &lt;Message Text=&quot;Clean completado. Iniciando build...&quot; Importance=&quot;high&quot; /&gt;&#13;&#10;  &lt;/Target&gt;&#13;&#10;&#13;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/GateKeep.Api/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/GateKeep.Api/Program.cs" />
              <option name="originalContent" value="using System.Text.Json.Serialization;&#10;using GateKeep.Api.Application.Acceso;&#10;using GateKeep.Api.Application.Anuncios;&#10;using GateKeep.Api.Application.Auditoria;&#10;using GateKeep.Api.Application.Beneficios;&#10;using GateKeep.Api.Application.Espacios;&#10;using GateKeep.Api.Application.Eventos;&#10;using GateKeep.Api.Application.Notificaciones;&#10;using GateKeep.Api.Application.Security;&#10;using GateKeep.Api.Application.Usuarios;&#10;using GateKeep.Api.Contracts.Usuarios;&#10;using GateKeep.Api.Domain.Enums;&#10;using GateKeep.Api.Endpoints.Acceso;&#10;using GateKeep.Api.Endpoints.Anuncios;&#10;using GateKeep.Api.Endpoints.Auditoria;&#10;using GateKeep.Api.Endpoints.Auth;&#10;using GateKeep.Api.Endpoints.Beneficios;&#10;using GateKeep.Api.Endpoints.Espacios;&#10;using GateKeep.Api.Endpoints.Eventos;&#10;using GateKeep.Api.Endpoints.Notificaciones;&#10;using GateKeep.Api.Endpoints.Usuarios;&#10;using GateKeep.Api.Endpoints.Shared;&#10;using GateKeep.Api.Infrastructure.Acceso;&#10;using GateKeep.Api.Infrastructure.Anuncios;&#10;using GateKeep.Api.Infrastructure.Auditoria;&#10;using GateKeep.Api.Infrastructure.Beneficios;&#10;using GateKeep.Api.Infrastructure.Caching;&#10;using GateKeep.Api.Infrastructure.Espacios;&#10;using GateKeep.Api.Infrastructure.Eventos;&#10;using GateKeep.Api.Infrastructure.Notificaciones;&#10;using GateKeep.Api.Infrastructure.Persistence;&#10;using GateKeep.Api.Infrastructure.Security;&#10;using GateKeep.Api.Infrastructure.Usuarios;&#10;using GateKeep.Infrastructure.QrCodes;&#10;using Microsoft.EntityFrameworkCore;&#10;using MongoDB.Driver;&#10;using MongoDB.Bson;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.IdentityModel.Tokens;&#10;using System.Text;&#10;using System.Security.Claims;&#10;using Microsoft.OpenApi.Models;&#10;using System.Reflection;&#10;using StackExchange.Redis;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Cargar config.json: hacerlo opcional para entornos Docker donde montamos config.Production.json&#10;builder.Configuration.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);&#10;// Cargar configuración específica para producción si existe&#10;builder.Configuration.AddJsonFile(&quot;config.Production.json&quot;, optional: true, reloadOnChange: true);&#10;// Permitir sobreescritura por variables de entorno&#10;builder.Configuration.AddEnvironmentVariables();&#10;&#10;// Swagger (exploración y documentación)&#10;builder.Services.AddEndpointsApiExplorer();&#10;builder.Services.AddSwaggerGen(c =&gt;&#10;{&#10;    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#10;    { &#10;        Title = &quot;GateKeep API&quot;, &#10;        Version = &quot;v1&quot;,&#10;        Description = &quot;API para el sistema de gestión de acceso GateKeep&quot;,&#10;        Contact = new OpenApiContact&#10;        {&#10;            Name = &quot;GateKeep Team&quot;,&#10;            Email = &quot;support@gatekeep.com&quot;&#10;        }&#10;    });&#10;&#10;    // Configuración para JWT&#10;    c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme&#10;    {&#10;        Description = &quot;JWT Authorization header usando el esquema Bearer. Ejemplo: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;        Name = &quot;Authorization&quot;,&#10;        In = ParameterLocation.Header,&#10;        Type = SecuritySchemeType.Http,&#10;        Scheme = &quot;Bearer&quot;,&#10;        BearerFormat = &quot;JWT&quot;&#10;    });&#10;&#10;    c.AddSecurityRequirement(new OpenApiSecurityRequirement&#10;    {&#10;        {&#10;            new OpenApiSecurityScheme&#10;            {&#10;                Reference = new OpenApiReference&#10;                {&#10;                    Type = ReferenceType.SecurityScheme,&#10;                    Id = &quot;Bearer&quot;&#10;                }&#10;            },&#10;            new string[] {}&#10;        }&#10;    });&#10;&#10;    // Incluir comentarios XML si los tienes&#10;    var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;&#10;    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);&#10;    if (File.Exists(xmlPath))&#10;    {&#10;        c.IncludeXmlComments(xmlPath);&#10;    }&#10;});&#10;&#10;// JSON&#10;builder.Services.ConfigureHttpJsonOptions(o =&gt;&#10;{&#10;    o.SerializerOptions.Converters.Add(new JsonStringEnumConverter());&#10;});&#10;&#10;// Configuración de Seguridad JWT&#10;builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)&#10;    .AddJwtBearer(options =&gt;&#10;    {&#10;        var jwtConfig = builder.Configuration.GetSection(&quot;jwt&quot;);&#10;        var jwtKey = jwtConfig[&quot;key&quot;] ?? throw new InvalidOperationException(&quot;JWT Key no configurada&quot;);&#10;        var jwtIssuer = jwtConfig[&quot;issuer&quot;] ?? &quot;GateKeep&quot;;&#10;        var jwtAudience = jwtConfig[&quot;audience&quot;] ?? &quot;GateKeepUsers&quot;;&#10;        &#10;        options.TokenValidationParameters = new TokenValidationParameters&#10;        {&#10;            ValidateIssuer = true,&#10;            ValidateAudience = true,&#10;            ValidateLifetime = true,&#10;            ValidateIssuerSigningKey = true,&#10;            ValidIssuer = jwtIssuer,&#10;            ValidAudience = jwtAudience,&#10;            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey)),&#10;            ClockSkew = TimeSpan.FromMinutes(5) // Permitir 5 minutos de diferencia&#10;        };&#10;&#10;        // Configuración para Swagger con logging completo&#10;        options.Events = new JwtBearerEvents&#10;        {&#10;            OnAuthenticationFailed = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Authentication Failed: {context.Exception.Message}&quot;);&#10;                Console.WriteLine($&quot;Exception Type: {context.Exception.GetType().Name}&quot;);&#10;                Console.WriteLine($&quot;Request Path: {context.Request.Path}&quot;);&#10;                &#10;                if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))&#10;                {&#10;                    Console.WriteLine(&quot;Token has expired&quot;);&#10;                    context.Response.Headers[&quot;Token-Expired&quot;] = &quot;true&quot;;&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidSignatureException))&#10;                {&#10;                    Console.WriteLine(&quot;Token signature is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidIssuerException))&#10;                {&#10;                    Console.WriteLine(&quot;Token issuer is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidAudienceException))&#10;                {&#10;                    Console.WriteLine(&quot;Token audience is invalid&quot;);&#10;                }&#10;                &#10;                return Task.CompletedTask;&#10;            },&#10;            OnTokenValidated = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Token Validated for user: {context.Principal?.Identity?.Name}&quot;);&#10;                var roles = context.Principal?.FindAll(ClaimTypes.Role).Select(c =&gt; c.Value).ToList() ?? new List&lt;string&gt;();&#10;                Console.WriteLine($&quot;User Roles: {string.Join(&quot;, &quot;, roles)}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnChallenge = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Challenge: {context.Error} - {context.ErrorDescription}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnMessageReceived = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Message Received from: {context.Request.Path}&quot;);&#10;                return Task.CompletedTask;&#10;            }&#10;        };&#10;    });&#10;&#10;// Configuración de Autorización&#10;builder.Services.AddAuthorizationBuilder()&#10;    .AddPolicy(&quot;AdminOnly&quot;, policy =&gt; policy.RequireRole(&quot;Admin&quot;))&#10;    .AddPolicy(&quot;FuncionarioOrAdmin&quot;, policy =&gt; policy.RequireRole(&quot;Funcionario&quot;, &quot;Admin&quot;))&#10;    .AddPolicy(&quot;AllUsers&quot;, policy =&gt; policy.RequireRole(&quot;Estudiante&quot;, &quot;Funcionario&quot;, &quot;Admin&quot;));&#10;&#10;// Configuración de CORS&#10;builder.Services.AddCors(options =&gt;&#10;{&#10;    options.AddPolicy(&quot;AllowFrontend&quot;, policy =&gt;&#10;    {&#10;        policy.WithOrigins(&quot;http://localhost:3000&quot;, &quot;http://127.0.0.1:3000&quot;)&#10;              .AllowAnyMethod()&#10;              .AllowAnyHeader()&#10;              .AllowCredentials();&#10;    });&#10;});&#10;&#10;// EF Core - PostgreSQL&#10;builder.Services.AddDbContext&lt;GateKeepDbContext&gt;(options =&gt;&#10;{&#10;    // Leer configuración desde config.json&#10;    var config = builder.Configuration.GetSection(&quot;database&quot;);&#10;    var host = config[&quot;host&quot;] ?? &quot;localhost&quot;;&#10;    var port = config[&quot;port&quot;] ?? &quot;5432&quot;;&#10;    var database = config[&quot;name&quot;] ?? &quot;GateKeep_Dev&quot;;&#10;    var username = config[&quot;user&quot;] ?? &quot;postgres&quot;;&#10;    var password = config[&quot;password&quot;] ?? &quot;dev_password&quot;;&#10;    &#10;    var connectionString = $&quot;Host={host};Port={port};Database={database};Username={username};Password={password};&quot;;&#10;    &#10;    options.UseNpgsql(connectionString, npgsql =&gt;&#10;    {&#10;        // Usar un esquema interno para el historial de migraciones&#10;        npgsql.MigrationsHistoryTable(&quot;__EFMigrationsHistory&quot;, schema: &quot;infra&quot;);&#10;    });&#10;});&#10;&#10;// Factory Pattern para Espacios&#10;builder.Services.AddScoped&lt;IEspacioRepository, EspacioRepository&gt;();&#10;builder.Services.AddScoped&lt;IEspacioFactory, EspacioFactory&gt;();&#10;&#10;// Servicios de Anuncios&#10;builder.Services.AddScoped&lt;IAnuncioRepository, AnuncioRepository&gt;();&#10;builder.Services.AddScoped&lt;IAnuncioService, AnuncioService&gt;();&#10;&#10;// Servicios de Beneficios&#10;builder.Services.AddScoped&lt;IBeneficioRepository, BeneficioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioService, BeneficioService&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioRepository, BeneficioUsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioService, BeneficioUsuarioService&gt;();&#10;&#10;// Servicios de Eventos&#10;builder.Services.AddScoped&lt;IEventoRepository, EventoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoService, EventoService&gt;();&#10;&#10;// Servicios de Usuarios&#10;builder.Services.AddScoped&lt;IUsuarioRepository, UsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IUsuarioFactory, UsuarioFactory&gt;();&#10;&#10;// Servicios de Acceso&#10;builder.Services.AddScoped&lt;IReglaAccesoRepository, ReglaAccesoRepository&gt;();&#10;builder.Services.AddScoped&lt;IReglaAccesoService, ReglaAccesoService&gt;();&#10;builder.Services.AddScoped&lt;IAccesoService, AccesoService&gt;();&#10;&#10;// Servicios de Seguridad&#10;builder.Services.AddScoped&lt;IPasswordService, PasswordService&gt;();&#10;builder.Services.AddScoped&lt;IAuthService, AuthService&gt;();&#10;&#10;// Utilidades&#10;builder.Services.AddSingleton&lt;QrCodeGenerator&gt;();&#10;&#10;// Servicios de Notificaciones MongoDB&#10;builder.Services.AddScoped&lt;INotificacionRepository, NotificacionRepository&gt;();&#10;builder.Services.AddScoped&lt;INotificacionService, NotificacionService&gt;();&#10;&#10;// Servicios de Auditoria MongoDB&#10;builder.Services.AddScoped&lt;IEventoHistoricoRepository, EventoHistoricoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoHistoricoService, EventoHistoricoService&gt;();&#10;&#10;// MongoDB - Configuración con Atlas y API estable&#10;builder.Services.AddSingleton&lt;IMongoClient&gt;(serviceProvider =&gt;&#10;{&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var connectionString = mongoConfig[&quot;connectionString&quot;] ?? &quot;mongodb://localhost:27017&quot;;&#10;    var useStableApi = mongoConfig.GetValue&lt;bool&gt;(&quot;useStableApi&quot;, false);&#10;    &#10;    try&#10;    {&#10;        if (useStableApi)&#10;        {&#10;            // Configuración para MongoDB Atlas con API estable&#10;            var settings = MongoClientSettings.FromConnectionString(connectionString);&#10;            settings.ServerApi = new ServerApi(ServerApiVersion.V1);&#10;            return new MongoClient(settings);&#10;        }&#10;        else&#10;        {&#10;            // Configuración local simple&#10;            return new MongoClient(connectionString);&#10;        }&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        throw new InvalidOperationException($&quot;Error conectando a MongoDB: {ex.Message}&quot;, ex);&#10;    }&#10;});&#10;&#10;builder.Services.AddScoped&lt;IMongoDatabase&gt;(serviceProvider =&gt;&#10;{&#10;    var client = serviceProvider.GetRequiredService&lt;IMongoClient&gt;();&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var databaseName = mongoConfig[&quot;databaseName&quot;] ?? &quot;GateKeepMongo&quot;;&#10;    &#10;    return client.GetDatabase(databaseName);&#10;});&#10;&#10;// Configuración de Redis&#10;builder.Services.AddStackExchangeRedisCache(options =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    options.Configuration = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    options.InstanceName = redisConfig[&quot;instanceName&quot;] ?? &quot;GateKeepRedis:&quot;;&#10;});&#10;&#10;// Servicios de Redis y Caching&#10;builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(serviceProvider =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    var connectionString = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    return ConnectionMultiplexer.Connect(connectionString);&#10;});&#10;&#10;builder.Services.AddSingleton&lt;ICacheMetricsService, CacheMetricsService&gt;();&#10;builder.Services.AddScoped&lt;ICacheService, RedisCacheService&gt;();&#10;&#10;// Servicios de Beneficios con Caching&#10;builder.Services.AddScoped&lt;ICachedBeneficioService, CachedBeneficioService&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;if (app.Environment.IsDevelopment())&#10;{&#10;    app.UseSwagger();&#10;    app.UseSwaggerUI(c =&gt;&#10;    {&#10;        c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;GateKeep API v1&quot;);&#10;        c.RoutePrefix = &quot;swagger&quot;;&#10;        c.DocumentTitle = &quot;GateKeep API Documentation&quot;;&#10;        c.DefaultModelsExpandDepth(-1); // Ocultar modelos por defecto&#10;        c.DisplayRequestDuration();&#10;        c.EnableDeepLinking();&#10;        // c.EnableFilter(); // ← Comentado para deshabilitar el filtro&#10;        c.ShowExtensions();&#10;        c.EnableValidator();&#10;    });&#10;}&#10;&#10;// Middleware de CORS&#10;app.UseCors(&quot;AllowFrontend&quot;);&#10;&#10;// Middleware de Seguridad&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;&#10;&#10;&#10;// Minimal API&#10;app.MapGet(&quot;/&quot;, () =&gt; Results.Redirect(&quot;/swagger&quot;)).ExcludeFromDescription();&#10;&#10;// Health&#10;app.MapGet(&quot;/health&quot;, () =&gt; Results.Ok(new { status = &quot;ok&quot; }))&#10;  .WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Health Check con ping usando BsonDocument&#10;app.MapGet(&quot;/health/mongodb&quot;, (IMongoClient mongoClient) =&gt;&#10;{&#10;    try&#10;    {&#10;        // Ping usando BsonDocument como en el código de Atlas&#10;        var result = mongoClient.GetDatabase(&quot;admin&quot;).RunCommand&lt;BsonDocument&gt;(new BsonDocument(&quot;ping&quot;, 1));&#10;        return Results.Ok(new { &#10;            status = &quot;ok&quot;, &#10;            database = &quot;MongoDB Atlas&quot;, &#10;            message = &quot;Pinged your deployment. You successfully connected to MongoDB!&quot;,&#10;            pingResult = result.ToString()&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a MongoDB Atlas: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// Redis Health Check&#10;app.MapGet(&quot;/health/redis&quot;, (IConnectionMultiplexer redis) =&gt;&#10;{&#10;    try&#10;    {&#10;        var isConnected = redis.IsConnected;&#10;        &#10;        return Results.Ok(new&#10;        {&#10;            status = isConnected ? &quot;ok&quot; : &quot;disconnected&quot;,&#10;            isConnected,&#10;            endpoints = redis.GetEndPoints().Select(ep =&gt; ep.ToString()).ToArray(),&#10;            message = &quot;Redis is connected and operational&quot;&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a Redis: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Clear Database - Eliminar todos los datos (Solo en desarrollo)&#10;app.MapDelete(&quot;/system/mongodb/clear&quot;, (IMongoDatabase mongoDatabase, IWebHostEnvironment env) =&gt;&#10;{&#10;    // Validación de seguridad - Solo permitir en desarrollo&#10;    if (!env.IsDevelopment())&#10;    {&#10;        return Results.Problem(&#10;            &quot;Este endpoint solo está disponible en modo desarrollo&quot;,&#10;            statusCode: 403&#10;        );&#10;    }&#10;&#10;    try&#10;    {&#10;        // Obtener lista de todas las colecciones&#10;        var collections = mongoDatabase.ListCollectionNames().ToList();&#10;        var deletedCollections = new List&lt;string&gt;();&#10;        var totalDocumentsDeleted = 0;&#10;&#10;        foreach (var collectionName in collections)&#10;        {&#10;            var collection = mongoDatabase.GetCollection&lt;BsonDocument&gt;(collectionName);&#10;            var count = collection.CountDocuments(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            &#10;            // Eliminar todos los documentos de la colección&#10;            var deleteResult = collection.DeleteMany(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            totalDocumentsDeleted += (int)deleteResult.DeletedCount;&#10;            deletedCollections.Add(collectionName);&#10;        }&#10;&#10;        return Results.Ok(new&#10;        {&#10;            status = &quot;success&quot;,&#10;            message = &quot;Base de datos MongoDB limpiada exitosamente&quot;,&#10;            environment = &quot;Development&quot;,&#10;            deletedCollections = deletedCollections,&#10;            totalDocumentsDeleted = totalDocumentsDeleted,&#10;            timestamp = DateTime.UtcNow&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error limpiando la base de datos MongoDB: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;)&#10;.WithSummary(&quot;Limpiar todos los datos de MongoDB&quot;)&#10;.WithDescription(&quot;Elimina todos los documentos de todas las colecciones en la base de datos MongoDB&quot;);&#10;&#10;// Endpoints&#10;app.MapAccesoEndpoints();&#10;app.MapAnuncioEndpoints();&#10;app.MapAuthEndpoints();&#10;app.MapEdificioEndpoints();&#10;app.MapEventoEndpoints();&#10;app.MapEventoHistoricoEndpoints();&#10;app.MapLaboratorioEndpoints();&#10;app.MapReglaAccesoEndpoints();&#10;app.MapSalonEndpoints();&#10;app.MapBeneficioEndpoints();&#10;app.MapNotificacionEndpoints();&#10;app.MapUsuarioEndpoints();&#10;app.MapUsuarioProfileEndpoints();&#10;app.MapCacheMetricsEndpoints(); // Endpoint de métricas de cache&#10;&#10;// Auto-aplicar migraciones al iniciar&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var db = scope.ServiceProvider.GetRequiredService&lt;GateKeepDbContext&gt;();&#10;    &#10;    if (app.Environment.IsDevelopment())&#10;    {&#10;        // En desarrollo: recrear BD automáticamente&#10;        db.Database.EnsureDeleted();&#10;        db.Database.EnsureCreated();&#10;        &#10;        // Seed data inicial&#10;        if (!db.Usuarios.Any())&#10;        {&#10;            var factory = scope.ServiceProvider.GetRequiredService&lt;IUsuarioFactory&gt;();&#10;            var passwordService = scope.ServiceProvider.GetRequiredService&lt;IPasswordService&gt;();&#10;            &#10;            // Crear usuario admin por defecto&#10;            var adminDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;admin@gatekeep.com&quot;,&#10;                Nombre = &quot;Administrador&quot;,&#10;                Apellido = &quot;Sistema&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;admin123&quot;),&#10;                Telefono = &quot;+1234567890&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Admin&#10;            };&#10;            &#10;            var admin = factory.CrearUsuario(adminDto);&#10;            db.Usuarios.Add(admin);&#10;            &#10;            // Crear estudiante de ejemplo&#10;            var estudianteDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;estudiante@gatekeep.com&quot;,&#10;                Nombre = &quot;Juan&quot;,&#10;                Apellido = &quot;Pérez&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;estudiante123&quot;),&#10;                Telefono = &quot;+1234567891&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Estudiante&#10;            };&#10;            &#10;            var estudiante = factory.CrearUsuario(estudianteDto);&#10;            db.Usuarios.Add(estudiante);&#10;            &#10;            // Crear funcionario de ejemplo&#10;            var funcionarioDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;funcionario@gatekeep.com&quot;,&#10;                Nombre = &quot;María&quot;,&#10;                Apellido = &quot;García&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;funcionario123&quot;),&#10;                Telefono = &quot;+1234567892&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Funcionario&#10;            };&#10;            &#10;            var funcionario = factory.CrearUsuario(funcionarioDto);&#10;            db.Usuarios.Add(funcionario);&#10;            &#10;            await db.SaveChangesAsync();&#10;        }&#10;    }&#10;    else&#10;    {&#10;        // En producción: solo migraciones&#10;        db.Database.Migrate();&#10;    }&#10;}&#10;&#10;&#10;app.Run();&#10;" />
              <option name="updatedContent" value="using System.Text.Json.Serialization;&#10;using GateKeep.Api.Application.Acceso;&#10;using GateKeep.Api.Application.Anuncios;&#10;using GateKeep.Api.Application.Auditoria;&#10;using GateKeep.Api.Application.Beneficios;&#10;using GateKeep.Api.Application.Espacios;&#10;using GateKeep.Api.Application.Eventos;&#10;using GateKeep.Api.Application.Notificaciones;&#10;using GateKeep.Api.Application.Security;&#10;using GateKeep.Api.Application.Usuarios;&#10;using GateKeep.Api.Contracts.Usuarios;&#10;using GateKeep.Api.Domain.Enums;&#10;using GateKeep.Api.Endpoints.Acceso;&#10;using GateKeep.Api.Endpoints.Anuncios;&#10;using GateKeep.Api.Endpoints.Auditoria;&#10;using GateKeep.Api.Endpoints.Auth;&#10;using GateKeep.Api.Endpoints.Beneficios;&#10;using GateKeep.Api.Endpoints.Espacios;&#10;using GateKeep.Api.Endpoints.Eventos;&#10;using GateKeep.Api.Endpoints.Notificaciones;&#10;using GateKeep.Api.Endpoints.Usuarios;&#10;using GateKeep.Api.Endpoints.Shared;&#10;using GateKeep.Api.Infrastructure.Acceso;&#10;using GateKeep.Api.Infrastructure.Anuncios;&#10;using GateKeep.Api.Infrastructure.Auditoria;&#10;using GateKeep.Api.Infrastructure.Beneficios;&#10;using GateKeep.Api.Infrastructure.Caching;&#10;using GateKeep.Api.Infrastructure.Espacios;&#10;using GateKeep.Api.Infrastructure.Eventos;&#10;using GateKeep.Api.Infrastructure.Notificaciones;&#10;using GateKeep.Api.Infrastructure.Persistence;&#10;using GateKeep.Api.Infrastructure.Security;&#10;using GateKeep.Api.Infrastructure.Usuarios;&#10;using GateKeep.Infrastructure.QrCodes;&#10;using Microsoft.EntityFrameworkCore;&#10;using MongoDB.Driver;&#10;using MongoDB.Bson;&#10;using Microsoft.AspNetCore.Authentication.JwtBearer;&#10;using Microsoft.IdentityModel.Tokens;&#10;using System.Text;&#10;using System.Security.Claims;&#10;using Microsoft.OpenApi.Models;&#10;using System.Reflection;&#10;using StackExchange.Redis;&#10;&#10;var builder = WebApplication.CreateBuilder(args);&#10;&#10;// Cargar config.json: hacerlo opcional para entornos Docker donde montamos config.Production.json&#10;builder.Configuration.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);&#10;// Cargar configuración específica para producción si existe&#10;builder.Configuration.AddJsonFile(&quot;config.Production.json&quot;, optional: true, reloadOnChange: true);&#10;// Permitir sobreescritura por variables de entorno&#10;builder.Configuration.AddEnvironmentVariables();&#10;&#10;// Swagger (exploración y documentación)&#10;builder.Services.AddEndpointsApiExplorer();&#10;builder.Services.AddSwaggerGen(c =&gt;&#10;{&#10;    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#10;    { &#10;        Title = &quot;GateKeep API&quot;, &#10;        Version = &quot;v1&quot;,&#10;        Description = &quot;API para el sistema de gestión de acceso GateKeep&quot;,&#10;        Contact = new OpenApiContact&#10;        {&#10;            Name = &quot;GateKeep Team&quot;,&#10;            Email = &quot;support@gatekeep.com&quot;&#10;        }&#10;    });&#10;&#10;    // Configuración para JWT&#10;    c.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme&#10;    {&#10;        Description = &quot;JWT Authorization header usando el esquema Bearer. Ejemplo: \&quot;Authorization: Bearer {token}\&quot;&quot;,&#10;        Name = &quot;Authorization&quot;,&#10;        In = ParameterLocation.Header,&#10;        Type = SecuritySchemeType.Http,&#10;        Scheme = &quot;Bearer&quot;,&#10;        BearerFormat = &quot;JWT&quot;&#10;    });&#10;&#10;    c.AddSecurityRequirement(new OpenApiSecurityRequirement&#10;    {&#10;        {&#10;            new OpenApiSecurityScheme&#10;            {&#10;                Reference = new OpenApiReference&#10;                {&#10;                    Type = ReferenceType.SecurityScheme,&#10;                    Id = &quot;Bearer&quot;&#10;                }&#10;            },&#10;            new string[] {}&#10;        }&#10;    });&#10;&#10;    // Incluir comentarios XML si los tienes&#10;    var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;&#10;    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);&#10;    if (File.Exists(xmlPath))&#10;    {&#10;        c.IncludeXmlComments(xmlPath);&#10;    }&#10;});&#10;&#10;// JSON&#10;builder.Services.ConfigureHttpJsonOptions(o =&gt;&#10;{&#10;    o.SerializerOptions.Converters.Add(new JsonStringEnumConverter());&#10;});&#10;&#10;// Configuración de Seguridad JWT&#10;builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)&#10;    .AddJwtBearer(options =&gt;&#10;    {&#10;        var jwtConfig = builder.Configuration.GetSection(&quot;jwt&quot;);&#10;        var jwtKey = jwtConfig[&quot;key&quot;] ?? throw new InvalidOperationException(&quot;JWT Key no configurada&quot;);&#10;        var jwtIssuer = jwtConfig[&quot;issuer&quot;] ?? &quot;GateKeep&quot;;&#10;        var jwtAudience = jwtConfig[&quot;audience&quot;] ?? &quot;GateKeepUsers&quot;;&#10;        &#10;        options.TokenValidationParameters = new TokenValidationParameters&#10;        {&#10;            ValidateIssuer = true,&#10;            ValidateAudience = true,&#10;            ValidateLifetime = true,&#10;            ValidateIssuerSigningKey = true,&#10;            ValidIssuer = jwtIssuer,&#10;            ValidAudience = jwtAudience,&#10;            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey)),&#10;            ClockSkew = TimeSpan.FromMinutes(5) // Permitir 5 minutos de diferencia&#10;        };&#10;&#10;        // Configuración para Swagger con logging completo&#10;        options.Events = new JwtBearerEvents&#10;        {&#10;            OnAuthenticationFailed = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Authentication Failed: {context.Exception.Message}&quot;);&#10;                Console.WriteLine($&quot;Exception Type: {context.Exception.GetType().Name}&quot;);&#10;                Console.WriteLine($&quot;Request Path: {context.Request.Path}&quot;);&#10;                &#10;                if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))&#10;                {&#10;                    Console.WriteLine(&quot;Token has expired&quot;);&#10;                    context.Response.Headers[&quot;Token-Expired&quot;] = &quot;true&quot;;&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidSignatureException))&#10;                {&#10;                    Console.WriteLine(&quot;Token signature is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidIssuerException))&#10;                {&#10;                    Console.WriteLine(&quot;Token issuer is invalid&quot;);&#10;                }&#10;                else if (context.Exception.GetType() == typeof(SecurityTokenInvalidAudienceException))&#10;                {&#10;                    Console.WriteLine(&quot;Token audience is invalid&quot;);&#10;                }&#10;                &#10;                return Task.CompletedTask;&#10;            },&#10;            OnTokenValidated = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Token Validated for user: {context.Principal?.Identity?.Name}&quot;);&#10;                var roles = context.Principal?.FindAll(ClaimTypes.Role).Select(c =&gt; c.Value).ToList() ?? new List&lt;string&gt;();&#10;                Console.WriteLine($&quot;User Roles: {string.Join(&quot;, &quot;, roles)}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnChallenge = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Challenge: {context.Error} - {context.ErrorDescription}&quot;);&#10;                return Task.CompletedTask;&#10;            },&#10;            OnMessageReceived = context =&gt;&#10;            {&#10;                Console.WriteLine($&quot;JWT Message Received from: {context.Request.Path}&quot;);&#10;                return Task.CompletedTask;&#10;            }&#10;        };&#10;    });&#10;&#10;// Configuración de Autorización&#10;builder.Services.AddAuthorizationBuilder()&#10;    .AddPolicy(&quot;AdminOnly&quot;, policy =&gt; policy.RequireRole(&quot;Admin&quot;))&#10;    .AddPolicy(&quot;FuncionarioOrAdmin&quot;, policy =&gt; policy.RequireRole(&quot;Funcionario&quot;, &quot;Admin&quot;))&#10;    .AddPolicy(&quot;AllUsers&quot;, policy =&gt; policy.RequireRole(&quot;Estudiante&quot;, &quot;Funcionario&quot;, &quot;Admin&quot;));&#10;&#10;// Configuración de CORS&#10;builder.Services.AddCors(options =&gt;&#10;{&#10;    options.AddPolicy(&quot;AllowFrontend&quot;, policy =&gt;&#10;    {&#10;        policy.WithOrigins(&quot;http://localhost:3000&quot;, &quot;http://127.0.0.1:3000&quot;)&#10;              .AllowAnyMethod()&#10;              .AllowAnyHeader()&#10;              .AllowCredentials();&#10;    });&#10;});&#10;&#10;// EF Core - PostgreSQL&#10;builder.Services.AddDbContext&lt;GateKeepDbContext&gt;(options =&gt;&#10;{&#10;    // Leer configuración desde config.json&#10;    var config = builder.Configuration.GetSection(&quot;database&quot;);&#10;    var host = config[&quot;host&quot;] ?? &quot;localhost&quot;;&#10;    var port = config[&quot;port&quot;] ?? &quot;5432&quot;;&#10;    var database = config[&quot;name&quot;] ?? &quot;GateKeep_Dev&quot;;&#10;    var username = config[&quot;user&quot;] ?? &quot;postgres&quot;;&#10;    var password = config[&quot;password&quot;] ?? &quot;dev_password&quot;;&#10;    &#10;    var connectionString = $&quot;Host={host};Port={port};Database={database};Username={username};Password={password};&quot;;&#10;    &#10;    options.UseNpgsql(connectionString, npgsql =&gt;&#10;    {&#10;        // Usar un esquema interno para el historial de migraciones&#10;        npgsql.MigrationsHistoryTable(&quot;__EFMigrationsHistory&quot;, schema: &quot;infra&quot;);&#10;    });&#10;});&#10;&#10;// Factory Pattern para Espacios&#10;builder.Services.AddScoped&lt;IEspacioRepository, EspacioRepository&gt;();&#10;builder.Services.AddScoped&lt;IEspacioFactory, EspacioFactory&gt;();&#10;&#10;// Servicios de Anuncios&#10;builder.Services.AddScoped&lt;IAnuncioRepository, AnuncioRepository&gt;();&#10;builder.Services.AddScoped&lt;IAnuncioService, AnuncioService&gt;();&#10;&#10;// Servicios de Beneficios&#10;builder.Services.AddScoped&lt;IBeneficioRepository, BeneficioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioService, BeneficioService&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioRepository, BeneficioUsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IBeneficioUsuarioService, BeneficioUsuarioService&gt;();&#10;&#10;// Servicios de Eventos&#10;builder.Services.AddScoped&lt;IEventoRepository, EventoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoService, EventoService&gt;();&#10;&#10;// Servicios de Usuarios&#10;builder.Services.AddScoped&lt;IUsuarioRepository, UsuarioRepository&gt;();&#10;builder.Services.AddScoped&lt;IUsuarioFactory, UsuarioFactory&gt;();&#10;&#10;// Servicios de Acceso&#10;builder.Services.AddScoped&lt;IReglaAccesoRepository, ReglaAccesoRepository&gt;();&#10;builder.Services.AddScoped&lt;IReglaAccesoService, ReglaAccesoService&gt;();&#10;builder.Services.AddScoped&lt;IAccesoService, AccesoService&gt;();&#10;&#10;// Servicios de Seguridad&#10;builder.Services.AddScoped&lt;IPasswordService, PasswordService&gt;();&#10;builder.Services.AddScoped&lt;IAuthService, AuthService&gt;();&#10;&#10;// Utilidades&#10;builder.Services.AddSingleton&lt;QrCodeGenerator&gt;();&#10;&#10;// Servicios de Notificaciones MongoDB&#10;builder.Services.AddScoped&lt;INotificacionRepository, NotificacionRepository&gt;();&#10;builder.Services.AddScoped&lt;INotificacionService, NotificacionService&gt;();&#10;&#10;// Servicios de Auditoria MongoDB&#10;builder.Services.AddScoped&lt;IEventoHistoricoRepository, EventoHistoricoRepository&gt;();&#10;builder.Services.AddScoped&lt;IEventoHistoricoService, EventoHistoricoService&gt;();&#10;&#10;// MongoDB - Configuración con Atlas y API estable&#10;builder.Services.AddSingleton&lt;IMongoClient&gt;(serviceProvider =&gt;&#10;{&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var connectionString = mongoConfig[&quot;connectionString&quot;] ?? &quot;mongodb://localhost:27017&quot;;&#10;    var useStableApi = mongoConfig.GetValue&lt;bool&gt;(&quot;useStableApi&quot;, false);&#10;    &#10;    try&#10;    {&#10;        if (useStableApi)&#10;        {&#10;            // Configuración para MongoDB Atlas con API estable&#10;            var settings = MongoClientSettings.FromConnectionString(connectionString);&#10;            settings.ServerApi = new ServerApi(ServerApiVersion.V1);&#10;            return new MongoClient(settings);&#10;        }&#10;        else&#10;        {&#10;            // Configuración local simple&#10;            return new MongoClient(connectionString);&#10;        }&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        throw new InvalidOperationException($&quot;Error conectando a MongoDB: {ex.Message}&quot;, ex);&#10;    }&#10;});&#10;&#10;builder.Services.AddScoped&lt;IMongoDatabase&gt;(serviceProvider =&gt;&#10;{&#10;    var client = serviceProvider.GetRequiredService&lt;IMongoClient&gt;();&#10;    var mongoConfig = builder.Configuration.GetSection(&quot;mongodb&quot;);&#10;    var databaseName = mongoConfig[&quot;databaseName&quot;] ?? &quot;GateKeepMongo&quot;;&#10;    &#10;    return client.GetDatabase(databaseName);&#10;});&#10;&#10;// Configuración de Redis&#10;builder.Services.AddStackExchangeRedisCache(options =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    options.Configuration = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    options.InstanceName = redisConfig[&quot;instanceName&quot;] ?? &quot;GateKeepRedis:&quot;;&#10;});&#10;&#10;// Servicios de Redis y Caching&#10;builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(serviceProvider =&gt;&#10;{&#10;    var redisConfig = builder.Configuration.GetSection(&quot;redis&quot;);&#10;    var connectionString = redisConfig[&quot;connectionString&quot;] ?? &quot;localhost:6379&quot;;&#10;    return ConnectionMultiplexer.Connect(connectionString);&#10;});&#10;&#10;builder.Services.AddSingleton&lt;ICacheMetricsService, CacheMetricsService&gt;();&#10;builder.Services.AddScoped&lt;ICacheService, RedisCacheService&gt;();&#10;&#10;// Servicios de Beneficios con Caching&#10;builder.Services.AddScoped&lt;ICachedBeneficioService, CachedBeneficioService&gt;();&#10;&#10;var app = builder.Build();&#10;&#10;// Swagger disponible en Development y Production (para demos)&#10;// En un ambiente productivo real, esto debería estar protegido o deshabilitado&#10;app.UseSwagger();&#10;app.UseSwaggerUI(c =&gt;&#10;{&#10;    c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;GateKeep API v1&quot;);&#10;    c.RoutePrefix = &quot;swagger&quot;;&#10;    c.DocumentTitle = &quot;GateKeep API Documentation&quot;;&#10;    c.DefaultModelsExpandDepth(-1); // Ocultar modelos por defecto&#10;    c.DisplayRequestDuration();&#10;    c.EnableDeepLinking();&#10;    // c.EnableFilter(); // ← Comentado para deshabilitar el filtro&#10;    c.ShowExtensions();&#10;    c.EnableValidator();&#10;});&#10;&#10;// Middleware de CORS&#10;app.UseCors(&quot;AllowFrontend&quot;);&#10;&#10;// Middleware de Seguridad&#10;app.UseAuthentication();&#10;app.UseAuthorization();&#10;&#10;&#10;&#10;// Minimal API&#10;app.MapGet(&quot;/&quot;, () =&gt; Results.Redirect(&quot;/swagger&quot;)).ExcludeFromDescription();&#10;&#10;// Health&#10;app.MapGet(&quot;/health&quot;, () =&gt; Results.Ok(new { status = &quot;ok&quot; }))&#10;  .WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Health Check con ping usando BsonDocument&#10;app.MapGet(&quot;/health/mongodb&quot;, (IMongoClient mongoClient) =&gt;&#10;{&#10;    try&#10;    {&#10;        // Ping usando BsonDocument como en el código de Atlas&#10;        var result = mongoClient.GetDatabase(&quot;admin&quot;).RunCommand&lt;BsonDocument&gt;(new BsonDocument(&quot;ping&quot;, 1));&#10;        return Results.Ok(new { &#10;            status = &quot;ok&quot;, &#10;            database = &quot;MongoDB Atlas&quot;, &#10;            message = &quot;Pinged your deployment. You successfully connected to MongoDB!&quot;,&#10;            pingResult = result.ToString()&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a MongoDB Atlas: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// Redis Health Check&#10;app.MapGet(&quot;/health/redis&quot;, (IConnectionMultiplexer redis) =&gt;&#10;{&#10;    try&#10;    {&#10;        var isConnected = redis.IsConnected;&#10;        &#10;        return Results.Ok(new&#10;        {&#10;            status = isConnected ? &quot;ok&quot; : &quot;disconnected&quot;,&#10;            isConnected,&#10;            endpoints = redis.GetEndPoints().Select(ep =&gt; ep.ToString()).ToArray(),&#10;            message = &quot;Redis is connected and operational&quot;&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error conectando a Redis: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;);&#10;&#10;// MongoDB Clear Database - Eliminar todos los datos (Solo en desarrollo)&#10;app.MapDelete(&quot;/system/mongodb/clear&quot;, (IMongoDatabase mongoDatabase, IWebHostEnvironment env) =&gt;&#10;{&#10;    // Validación de seguridad - Solo permitir en desarrollo&#10;    if (!env.IsDevelopment())&#10;    {&#10;        return Results.Problem(&#10;            &quot;Este endpoint solo está disponible en modo desarrollo&quot;,&#10;            statusCode: 403&#10;        );&#10;    }&#10;&#10;    try&#10;    {&#10;        // Obtener lista de todas las colecciones&#10;        var collections = mongoDatabase.ListCollectionNames().ToList();&#10;        var deletedCollections = new List&lt;string&gt;();&#10;        var totalDocumentsDeleted = 0;&#10;&#10;        foreach (var collectionName in collections)&#10;        {&#10;            var collection = mongoDatabase.GetCollection&lt;BsonDocument&gt;(collectionName);&#10;            var count = collection.CountDocuments(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            &#10;            // Eliminar todos los documentos de la colección&#10;            var deleteResult = collection.DeleteMany(FilterDefinition&lt;BsonDocument&gt;.Empty);&#10;            totalDocumentsDeleted += (int)deleteResult.DeletedCount;&#10;            deletedCollections.Add(collectionName);&#10;        }&#10;&#10;        return Results.Ok(new&#10;        {&#10;            status = &quot;success&quot;,&#10;            message = &quot;Base de datos MongoDB limpiada exitosamente&quot;,&#10;            environment = &quot;Development&quot;,&#10;            deletedCollections = deletedCollections,&#10;            totalDocumentsDeleted = totalDocumentsDeleted,&#10;            timestamp = DateTime.UtcNow&#10;        });&#10;    }&#10;    catch (Exception ex)&#10;    {&#10;        return Results.Problem($&quot;Error limpiando la base de datos MongoDB: {ex.Message}&quot;);&#10;    }&#10;})&#10;.WithTags(&quot;System&quot;)&#10;.WithSummary(&quot;Limpiar todos los datos de MongoDB&quot;)&#10;.WithDescription(&quot;Elimina todos los documentos de todas las colecciones en la base de datos MongoDB&quot;);&#10;&#10;// Endpoints&#10;app.MapAccesoEndpoints();&#10;app.MapAnuncioEndpoints();&#10;app.MapAuthEndpoints();&#10;app.MapEdificioEndpoints();&#10;app.MapEventoEndpoints();&#10;app.MapEventoHistoricoEndpoints();&#10;app.MapLaboratorioEndpoints();&#10;app.MapReglaAccesoEndpoints();&#10;app.MapSalonEndpoints();&#10;app.MapBeneficioEndpoints();&#10;app.MapNotificacionEndpoints();&#10;app.MapUsuarioEndpoints();&#10;app.MapUsuarioProfileEndpoints();&#10;app.MapCacheMetricsEndpoints(); // Endpoint de métricas de cache&#10;&#10;// Auto-aplicar migraciones al iniciar&#10;using (var scope = app.Services.CreateScope())&#10;{&#10;    var db = scope.ServiceProvider.GetRequiredService&lt;GateKeepDbContext&gt;();&#10;    &#10;    if (app.Environment.IsDevelopment())&#10;    {&#10;        // En desarrollo: recrear BD automáticamente&#10;        db.Database.EnsureDeleted();&#10;        db.Database.EnsureCreated();&#10;        &#10;        // Seed data inicial&#10;        if (!db.Usuarios.Any())&#10;        {&#10;            var factory = scope.ServiceProvider.GetRequiredService&lt;IUsuarioFactory&gt;();&#10;            var passwordService = scope.ServiceProvider.GetRequiredService&lt;IPasswordService&gt;();&#10;            &#10;            // Crear usuario admin por defecto&#10;            var adminDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;admin@gatekeep.com&quot;,&#10;                Nombre = &quot;Administrador&quot;,&#10;                Apellido = &quot;Sistema&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;admin123&quot;),&#10;                Telefono = &quot;+1234567890&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Admin&#10;            };&#10;            &#10;            var admin = factory.CrearUsuario(adminDto);&#10;            db.Usuarios.Add(admin);&#10;            &#10;            // Crear estudiante de ejemplo&#10;            var estudianteDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;estudiante@gatekeep.com&quot;,&#10;                Nombre = &quot;Juan&quot;,&#10;                Apellido = &quot;Pérez&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;estudiante123&quot;),&#10;                Telefono = &quot;+1234567891&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Estudiante&#10;            };&#10;            &#10;            var estudiante = factory.CrearUsuario(estudianteDto);&#10;            db.Usuarios.Add(estudiante);&#10;            &#10;            // Crear funcionario de ejemplo&#10;            var funcionarioDto = new UsuarioDto&#10;            {&#10;                Id = 0,&#10;                Email = &quot;funcionario@gatekeep.com&quot;,&#10;                Nombre = &quot;María&quot;,&#10;                Apellido = &quot;García&quot;,&#10;                Contrasenia = passwordService.HashPassword(&quot;funcionario123&quot;),&#10;                Telefono = &quot;+1234567892&quot;,&#10;                FechaAlta = DateTime.UtcNow,&#10;                Credencial = TipoCredencial.Vigente,&#10;                Rol = Rol.Funcionario&#10;            };&#10;            &#10;            var funcionario = factory.CrearUsuario(funcionarioDto);&#10;            db.Usuarios.Add(funcionario);&#10;            &#10;            await db.SaveChangesAsync();&#10;        }&#10;    }&#10;    else&#10;    {&#10;        // En producción: solo migraciones&#10;        db.Database.Migrate();&#10;    }&#10;}&#10;&#10;&#10;app.Run();" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>